<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://520cxy.github.io</id>
    <title>LL.的小窝</title>
    <updated>2021-07-13T10:48:16.917Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://520cxy.github.io"/>
    <link rel="self" href="https://520cxy.github.io/atom.xml"/>
    <subtitle>共道人间惆怅事,不知今夕是何年 ——《周秦行纪》</subtitle>
    <logo>https://520cxy.github.io/images/avatar.png</logo>
    <icon>https://520cxy.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, LL.的小窝</rights>
    <entry>
        <title type="html"><![CDATA[灯泡！打牌！大炮！]]></title>
        <id>https://520cxy.github.io/post/deng-pao-da-pai-da-pao/</id>
        <link href="https://520cxy.github.io/post/deng-pao-da-pai-da-pao/">
        </link>
        <updated>2021-07-02T12:28:40.000Z</updated>
        <content type="html"><![CDATA[<p>the shy告诉我dp联赛要一直考到状压，然后我想起来我dp一直不咋行，这可咋整<br>
<font size=6><strong>区间DP</strong></font></p>
<p><font size = 5>朴素模板O（n<sup>3</sup>）</font><br>
<img src="https://520cxy.github.io/post-images/1625291612126.png" alt="" loading="lazy"><br>
例题：<a href="https://vjudge.net/problem/51Nod-1021">石子合并easy</a></p>
<p><font size=5>题目变形，<strong>线性变环状</strong></font><br>
思路：环状以后合并区间的情况就可以从后往前合并，最后合并完成可能是1<sub>n,2</sub>n<sub>1,3</sub>n~2.....这种n个石子合并的情况。所以我们可以破环成链，将前n-1各元素也放到n后面构成一个线性的环状序列，在对这个序列dp即可<br>
例题：<a href="https://www.luogu.com.cn/problem/P1880">[NOI1995] 石子合并</a><br>
大体思路与原题差不多，就是处理的时候前缀和在n后要接上1，2，3...然后状态转移时，起点要一直枚举到2*n，最后取最值时，枚举起点i从1~n，取f[i][n+i-1]要<strong>取一圈</strong></p>
<p><font size=5>时间优化 <strong>四边形优化O(n<sup>2</sup>)</strong></font><br>
思路：在查找最优分割点的时候，我们浪费了大量时间。那么我们可以把最优分割点保存下来，在查找的时候利用保存的最优分割点来优化查找过程。<br>
四边形不等式优化：<br>
（1）功能：用来寻找，s[i][j](i~j的最优分割点）与其他分割点的关系<br>
（2）不等式内容：如果某东西满足a&lt;b&lt;=c&lt;d且f[a][c]+f[b][d]&lt;=f[a][d]+f[b][c],则说这个东西满足四边形不等式。简而言之：交叉小于包含！<br>
（3）结论关系：s[i][j-1]&lt;=s[i][j]&lt;=s[i+1][j]<br>
（4）证明过程：<br>
0.证明w满足四边形不等式，这里w是m的附属量，形如m[i,j]=opt{m[i,k]+m[k,j]+w[i,j]}，此时大多要先证明w满足条件才能进一步证明m满足条件<br>
1.证明m满足四边形不等式<br>
2.证明s[i,j-1]≤s[i,j]≤s[i+1,j]<br>
<img src="https://520cxy.github.io/post-images/1625270269425.png" alt="" loading="lazy"><br>
结论关系：s[i][j-1]&lt;=s[i][j]&lt;=s[i+1][j]<br>
<img src="https://520cxy.github.io/post-images/1625270776603.png" alt="" loading="lazy"><br>
<a href="https://blog.csdn.net/noiau/article/details/72514812">证明详解</a><br>
<img src="https://520cxy.github.io/post-images/1625282987592.png" alt="" loading="lazy"><br>
例题<a href="http://poj.org/problem?id=2955">Brackets</a><br>
如果两个括号匹配，那么它的状态就是<strong>该匹配成功的括号内的区间左右长度状态+2</strong>然后按照朴素方法做输出就行<br>
if(s[i] 与 s[j]匹配） dp[i][j] = d[[i+1][j-1] +2;<br>
dp[i][j] = max(dp[i][j],dp[i][k]+dp[k+1][j]);</p>
<p><a href="http://poj.org/problem?id=1651">Multiplication Puzzle</a><br>
因为最后都要删掉中间所有的数字，所以我们分隔一个个小区间删数字，合并区间求最小。那么我们的状态就是目前删掉的数字区间，但是我们分割的时候的意思是抽一个卡片出来，所以这个卡片不能在已经抽出的状态里面，所以dp[i][j]里面是不包含j卡片的！<br>
状态转移方程：dp[i][j]表示抽出第i~j-1张卡片时候的最小值<br>
dp[i][j] = min(dp[i][j],dp[i][k] + dp[k+1][j] +num[i-1]*num[k]*num[j]);</p>
<p>整数划分（四）<br>
（1）题意：给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积<br>
（2）思路：这里给的乘号是有限个，所以状态方程里必须包含使用乘号的个数，此外还要包含区间长度。所以怎么用二维dp实现包含m和n，我们可以用dp[i][j]表示在第1~i个字符里插入j个乘号的最大值。<br>
（3）状态转移方程 dp[i][j]表示在第1<sub>i个字符里插入j个乘号的最大值；用num[i][j]表示第i</sub>j个字符表示的数字；<br>
dp[i][j] = max(dp[i][j],dp[k][j-1]*num[k+1][i])</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4632">Palindrome subsequence</a><br>
(1)题意：给你一个字符串，求出其最多的可构成的回文字串（不要求连续），注：这里不同的回文字串只要求位置不同即可视为不同，如：aaaaa 的最多回文子串数目是 31.</p>
<p>（2）思路：用dp[i][j]表示状态，表示i~j里最多的回文字串数目，假设现在我们要求dp[i][j]：</p>
<p>a.首先：由前一个状态知：dp[i][j] = dp[i+1][j]并上dp[i][j-1] （因为区间尽可能大而且状态要在dp[i][j]之前，而且回文子串不要求 连续），由容斥原理得：dp[i+1][j] U dp[i][j-1] = dp[i+1][j]+dp[i][j-1] - dp[i+1][j] n dp[i][j-1]= dp[i+1[j]+dp[i][j-1] - dp[i+1][j-1]<br>
注意：这是一个固定的状态，每一个状态都由这个公式推出初始状态，是必须的，不是可选择地<br>
b.其次：如果s[i] == s[j] ,那么两端单独就可以构成回文子序列，而且与dp[i+1][j],dp[i][j-1],dp[i+1][j-1]，中的回文序列又可以构成新的回文序列，所以此时dp[i][j] = dp[i+1][j] U dp[i][j-1] + dp[i+1][j-1] +1;而dp[i][j]已经更新为 dp[i+1][j] U dp[i][j-1]，所以dp[i][j] = dp[i][j] + dp[i+1][j-1] +1;<br>
(3)状态转移方程： dp[i][j]表示i~j内最多的回文字串数目<br>
dp[i][j] = dp[i+1][j]+dp[i][j-1] -dp[i+1][j-1] (容斥）<br>
if(s[i] == s[j]) dp[i][j] = dp[i][j] +dp[i+1][j-1] +1; （思维）<br>
注：这里因为容斥时有减法，所以要先加上模再取模，要不会出现负数！</p>
<p><font size=6><strong>背包DP</strong></font><br>
<font size=5>01背包</font><br>
该问题特点：<strong>每种物品只有一件，决策为放或不放</strong>，我们设子问题为<strong>状态f[i][j]表示前i件物品放到容量为j的背包中的最大价值</strong>，那么对于一件物品i，代价w[i],价值v[i],<br>
<img src="https://520cxy.github.io/post-images/1625281778957.png" alt="" loading="lazy"><br>
该方法为最朴素的算法<strong>O(VN)</strong><br>
<font size=4><strong>空间优化</strong></font><br>
先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1...N，每次算出来二维数组f[i][0...V]的所有值。那么，如果只用一个数组f[0...V]，能不能保证第i次循环结束后f[j]中表示的就是我们定义的状态f[i][j]呢？f[i][j]是由f[i−1][j]和f[i−1][j−w[i]]两个子问题递推而来，能否保证在推f[i][j]时（也即在第i次主循环中推f[j]时）能够得到f[i−1][j]和f[i−1][j−w[i]]的值呢？事实上，这要求<strong>在每次主循环中我们以j=V...0的顺序推f[j]，这样才能保证推f[j]时f[j−w[i]]保存的是状态f[i−1][j−w[i]]的值</strong>。至于为什么下面有详细解释。代码如下：<br>
<img src="https://520cxy.github.io/post-images/1625282679127.png" alt="" loading="lazy"><br>
其中的f[j]=max(f[j],f[j−w[i]])一句恰就相当于我们的转移方程f[i][j]=max(f[i−1][j],f[i−1][j−w[i]])，因为现在的f[j−w[i]]就相当于原来的f[i−1][j−w[i]]。如果将V的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][j]由f[i][j−w[i]]推知，与本题意不符，但它却是另一个重要的背包问题（完全背包）最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。<br>
事实上，使用一维数组解01背包的程序在后面会被多次用到，以后的代码中就直接调用不再加以说明。<br>
<img src="https://520cxy.github.io/post-images/1625282638813.png" alt="" loading="lazy"><br>
注意这个过程里的处理与前面给出的代码有所不同。前面的示例程序写成j=V...0是为了在程序中体现每个状态都按照方程求解了，避免不必要的思维复杂度。而这里既然已经抽象成看作黑箱的过程了，就可以加入优化。费用为w[i]的物品不会影响状态f[0...j−1]，这是显然的。</p>
<p><font size=5>完全背包</font><br>
该问题特点：<strong>每个物品都可以无限用</strong><br>
基本思路：<br>
这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，用f[i][j]表示前i种物品恰放入一个容量为V的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：<br>
f[i][j] = max(f[i-1][j], f[i-1][j-k<em>w[i]]+k</em>v[i])，k为该物品取了多少件<br>
这跟01背包问题一样有O(VN)个状态需要求解，但求解每个状态的时间已经不是常数了，求解状态f[i][j]的时间是O(V/w[i])，总的复杂度可以认为是O(N∗Σ(V/w[i]))，是比较大的。将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。<br>
<font size=4><strong>O(VN)的算法</strong></font><br>
<img src="https://520cxy.github.io/post-images/1625450345723.png" alt="" loading="lazy"><br>
细心的dalao会发现，这个代码与01背包的代码只有j的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么01背包中要按照j=V...0的逆序来循环。这是因为要保证第i次循环中的状态f[i][j]是由状态f[i−1][j−w[i]]递推而来。换句话说，这<strong>正是为了保证每件物品只选一次</strong>，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i−1][j−w[i]]。而现在完全背包的特点恰是每种物品可选无限件**，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][j−w[i]]**，所以就可以并且必须采用j=0...V的顺序循环。这就是这个简单的程序为何成立的道理。值得一提的是，上面的伪代码中两层for循环的次序可以颠倒。这个结论有可能会带来算法时间常数上的优化。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[狗崽腿]]></title>
        <id>https://520cxy.github.io/post/gou-zai-tui/</id>
        <link href="https://520cxy.github.io/post/gou-zai-tui/">
        </link>
        <updated>2021-06-29T01:56:19.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7115">[NOIP2020] 移球游戏</a><br>
<font color = purple><strong>省选/NOI-</strong></font><br>
<strong>好像就是大大大大大模拟</strong>， 利用栈的特性，对每列每种颜色构造出“全色列”，对于每次构造，我们采用一个空栈和一个满栈，我们枚举每次移动的颜色，记每列该颜色的数量为t<sub>1</sub>，那么每次先移动空栈前一个t<sub>1</sub>个球到空栈里，然后将当前栈里的当前颜色的移动到空栈前一个栈上，将其他颜色的球移动到空栈上；之后再把空栈上的n-t<sub>1</sub>个球放到当前栈上，之后我们我们看当前列的下一列，把这列当做当前列，再把当前列的其他颜色放到上一列上，然后当前颜色放到空列上，我们记这样的操作为一次操作。最后只要枚举颜色，在每个颜色进行枚举栈并循环操作就能分离所有颜色了。</p>
<p><a href="https://codeforces.com/problemset/problem/618/F">Double Knapsack</a><br>
<font color = black><strong>NOI/NOI+/CTSC</strong></font><br>
显然先对每个集合内元素升序排序，做前缀和而要使他们的元素和相等，我们想到的肯定是选择每个集合内的某两个区间，<s>正确性显然</s>我们设<strong>c<sub>i</sub>表示最大的j使得s<sub>ai</sub>&gt;=s<sub>bj</sub></strong> 整理得：s<sub>ai</sub>-s<sub>b<sub>ci</sub></sub> &lt; b<sub>ci+1</sub><br>
所以题目的差共有n+1种可能。再根据狗朝园里可知至少有两个差值是相等的之后就枚举就行了<br>
哇，k掉了黑题！</p>
<p><a href="https://atcoder.jp/contests/arc103/tasks/arc103_d">Distance Sums</a><br>
<font color = purple><strong>省选/NOI-</strong></font><br>
这题有个奇怪的结论，就是由于你的d是一定的，然后距离根最大的点肯定是叶子，而且这题中，根不是重心也在重心周围，我们对于每个距离就选择从叶子结点往上做，最后判断这是不是一棵树就行；</p>
<p><a href="https://codeforces.com/problemset/problem/1495/C">CF1495C Garden of the Sun</a><br>
<font color = blue><strong>提高+/省选-</strong></font><br>
结论：每两行进行操作，先把第一列全染了，然后某两排X中间的某一排的第二列有X就会出锅，所以这种情况就把第二列全染成X</p>
<p><a href="https://codeforces.com/problemset/problem/1408/F">CF1408F Two Different</a><br>
<font color = blue><strong>提高+/省选-</strong></font><br>
结论：当n为2次幂时，我们可以直接n log n 次选择两两染色，不为2次幂时，我们把n分为1 ~ 2<sup>k</sup>，和n-2<sup>k</sup>+1 ~ n，两个区间进行操作，显然前面就按照结论操作，后面的那个区间，如果前面是一种颜色，后面是另一种颜色就做完了，k为最大2<sup>k</sup> &lt;= n</p>
<p><a href="https://codeforces.com/problemset/problem/1333/E">CF1333E Road to 1600</a><br>
<font color = purple><strong>省选/NOI-</strong></font><br>
首先手推出一个3*3内，车一定比后优的矩阵</p>
<blockquote>
<p>{1， 5， 8<br>
3， 6， 4<br>
2， 9， 7}</p>
</blockquote>
<p>然后其他格子就填充后与车同级的路线，因为最后必定会进入这个3*3的矩阵内，这时后就被卡掉了，就保证了车的优秀</p>
<p><a href="https://codeforces.com/problemset/problem/804/E">CF804E The same permutation</a><br>
<font color = black><strong>NOI/NOI+/CTSC</strong></font><br>
对于一个n， 如果%4=2||3就无解当n被4整除时，发现这些数4个一块，按照(1,2) (3,4) (1,4) (2,3) (1,3)(2,4) 交换刚好能把块内循环一次,而块与块之间的循环，我们设(x, y)表示第一块的x与第二块的y交换</p>
<blockquote>
<p>• (1,1) (2,2) (1,2) (2,1)<br>
• (1,3) (2,4) (1,4) (2,3)<br>
• (3,1) (4,2) (3,2) (4,1)<br>
• (3,3) (4,4) (3,4) (4,3)</p>
</blockquote>
<p><a href="https://codeforces.com/problemset/problem/858/F">CF858F Wizard's Tour</a><br>
<font color = purple><strong>省选/NOI-</strong></font><br>
这题先考虑树的解法，对于每一个点，过程大致是这样的：先解决儿子的问题 -&gt;再解决当前点的问题-&gt; 把不能解决的问题留给父亲。<br>
上述的解决问题就是指两条相邻边的匹配，可以发现，只有根节点一条边可能会匹配不到，其他的要么自己要么父亲都处理掉了，这种算法的正确性就很显然了，因为它构造出的答案已经达到了可能的答案上界。<br>
拓展到图的情况，我们对每一个联通块都考虑它的生成树，我们把返祖边当作连向儿子的边处理即可，正确性可以用树的方法说明。<br>
在具体实现中，我们把每一个点上未匹配的边存到p数组中，然后我们在访问儿子时需要把这条边删去，用网络流类似的方法。<strong>边数一开始记得赋1</strong></p>
<p><a href="https://codeforces.com/problemset/problem/1450/C2">CF1450C2 Errich-Tac-Toe (Hard Version)</a><br>
<font color = blue><strong>提高+/省选-</strong></font><br>
结论：如果我们能让连续的三个棋子中至少出现一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 和一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>，那么就能避免三个连续相同棋子的情况，形成平局<br>
（相当于我们需要选择间隔相同的 X XX 对角线与 O OO 对角线对棋盘进行分割，避免出现三个棋子同色的情况）<br>
同一排或者同一列三个连续的棋子满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo>)</mo><mi mathvariant="normal">%</mi><mn>3</mn><mo>=</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">(i + j) \% 3 == 0, 1, 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mord">%</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span></span>因此我们可以按照 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">( i + j ) % 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 来对所有的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span> 进行统计，假设数量为X<sub>0</sub>,X<sub>1</sub>,X<sub>2</sub>,O<sub>0</sub>,O<sub>1</sub>,O<sub>2</sub><br>
显然k=X<sub>0</sub>+X<sub>1</sub>+X<sub>2</sub>+O<sub>0</sub>+O<sub>1</sub>+O<sub>2</sub>,需要使得连续的三个棋子中出现一个X或O，那么我们需要在X<sub>0</sub>,X<sub>1</sub>,X<sub>2</sub>中选择一个并在O<sub>0</sub>,O<sub>1</sub>,O<sub>2</sub>中选择一个位置不同的进行修改，找到最小的X<sub>i</sub>+O<sub>j</sub>,满足X<sub>i</sub>+O<sub>j</sub>&lt;=⌊ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>k</mi><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{k}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>⌋,最后根据选择的两个数字对棋盘棋子进行翻转输出就行</p>
<p><a href="http://codeforces.com/problemset/problem/1494/D">Codeforces 1494D Dogeforces</a><br>
<font color = blue><strong>提高+/省选-</strong></font><br>
因为上级严格比下级大，把a[i][j]从小到大排序，然后就能从下往上构造了,并查集模拟一下<br>
注意排序的同时，还要把i,j排序，也就是一堆相同的值中，先把i的全部给构造完了，这样就不会出现冲突了<br>
我还是举个栗子<br>
比如1 2 3 4都是父亲是5，但是你在排序的时候搞出了1 2父亲是5，然后处理3 4，发现他们的父节点都是他们自己，所以搞出个新节点父亲6，最后发现1,3的父亲还是权值和5,6一样，就会出问题，相当于多创建了一个点，但如果一开始排序就先 1 2 ,1 3,1 4,就会只有一个父亲5</p>
<p><a href="http://codeforces.com/problemset/problem/1004/D">CF1004D Sonya and Matrix</a><br>
<font color = purple><strong>省选/NOI-</strong></font><br>
发现，当我们确定了0的横坐标时，其纵坐标也可以确定了，设 0的坐标为（x，y），矩阵的大小为（m，n），矩阵第一行第一列为（1，1）(在这里我们要把矩阵翻过来看）；设 a=x-1+y-1 , b=m-x +n-y;<br>
则a表示0到（1，1）的距离，b表示0到m，n的距离，这里注意，很容易知道b的值就是输入数中最大的那一个，因为最大的那个数距离0是最远的。<br>
将a=x-1+y-1 , b=m-x +n-y合并得 a=m+n-2-b;代入a=x-1+y-1中得到y=n+m-b-x; 如果 a[i] != 4*i,x=i;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[summer？]]></title>
        <id>https://520cxy.github.io/post/shu-jia/</id>
        <link href="https://520cxy.github.io/post/shu-jia/">
        </link>
        <updated>2021-06-29T00:23:17.000Z</updated>
        <content type="html"><![CDATA[<p><font size=6><strong>6.29:</strong></font><br>
<a href="https://www.luogu.com.cn/problem/P2363">马农</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
标签给定的是dp，其实就是暴力枚举， 对于限定条件<font color=red>矩阵权值一样，且只有一个交点。</font>就可以直接枚举矩阵权值与交点；<br>
先做二维矩阵和，再N<sup>2</sup>枚举交点，之后分情况枚举矩阵的权值和，开个数组存不同和的方案数，然后ans加过去就过了，而对于枚举的两个矩阵只有一个左上，一个右下；一个右上，一个左下这两种。<br>
<img src="https://520cxy.github.io/post-images/1625713851078.png" alt="" loading="lazy"></p>
<p><a href="https://www.luogu.com.cn/problem/P4655">[CEOI2017]Building Bridges</a><br>
<font color=purple><strong>省选/NOI-</strong></font><br>
显然，对于第i个柱子，我们连接的代价为建桥代价+拆除代价：W<sub>总</sub> = (h<sub>i</sub>-h<sub>j</sub>)<sup>2</sup>+(s<sub>i-1</sub>-s<sub>j</sub>)， (j为上一个柱子端点)化简后得：W<sub>总</sub>=h<sub>i</sub><sup>2</sup>+h<sub>j</sub><sup>2</sup>-2h<sub>i</sub>h<sub>j</sub>+s<sub>i-1</sub>-s<sub>j</sub>，而影响对于i总代价的变量只有j，设a<sub>j</sub> = -2h<sub>j</sub>, b<sub>j</sub>=h<sub>j</sub>+f<sub>j</sub><sup>2</sup>-s<sub>j</sub>;<br>
f<sub>i</sub> = h<sub>i</sub><sup>2</sup>+s<sub>i-1</sub>+min{a<sub>j</sub>h<sub>i</sub>+b<sub>j</sub>}<br>
问题就转化为<font color=red>给定直线y<sub>j</sub>=a<sub>j</sub>x+b<sub>j</sub>,求当x=h<sub>i</sub>时，y<sub>j</sub>的最小值</font><br>
而对于这样动态插入直线，维护最优解，我跟wcr学到了<strong>李超线段树</strong></p>
<p><font size=6 color=red><strong>7.1 :</strong></font><br>
<font color=red size=6><strong>！！！庆祝中国共产党建立100周年！！！</strong></font><br>
<a href="https://www.luogu.com.cn/problem/P1773">符文之语</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
f[i][j]表示用前i个字符，满足最小乘积（对m取余后的）所需要划分的阶段（要加的括号），<br>
对于每个i可以取到的j，由f[j][k]推出当前位，之后取最优解<br>
<img src="https://520cxy.github.io/post-images/1625122781301.png" alt="" loading="lazy"></p>
<p><a href="https://www.luogu.com.cn/problem/P2330"> [SCOI2005]繁忙的都市</a><br>
<font color = yellow><strong>普及/提高-</strong></font><br>
最小生成树kruskal的板子题，最少边数肯定是n-1，最小值的最大值取max就行</p>
<p><a href="https://www.luogu.com.cn/problem/P1339">[USACO09OCT]Heat Wave G</a><br>
<font color = yellow><strong>普及/提高-</strong></font><br>
迪杰斯特拉加个堆优化就过了，注意题目是<strong>无向图</strong>所以<font size=5><strong>要建双向边！！！</strong></font>,我忘了，交了好几遍才发现😭😭😭</p>
<p><a href="https://www.luogu.com.cn/problem/P1111">修复公路</a><br>
<font color = yellow><strong>普及/提高-</strong></font><br>
贪心从时间小的开始修，每修一条路，用并查集判断两个村是不是已经联通了，如果没有就合并，连接的村庄数量cnt++，当cnt==n-1就直接输出当前这条路的时间return 0，否则接着修，如果路修完就结束循环，puts(&quot;-1&quot;);</p>
<p><font size=6><strong>7.2</strong>:</font><br>
<a href="https://www.luogu.com.cn/problem/P1991">无线通讯网</a><br>
<font color=green><strong>普及+/提高</strong></font><br>
感觉写题面的人语文跟没学过一样，非要整这些花里胡哨的，看都看不懂，说白了就是在坐标系上给你p个点，然后要求全联通的距离最小，给了s就相当于你可以连接任意s/2对点并且代价为0，直接上克鲁斯卡尔，然后要让代价最小，我们肯定把距离最大的变为0，所以相当于最大的那s个点不用连了，只要边数==p-s就做完了，然后ans一直更新边权就行，还有就是建边的时候，每个点和其他的p-1个点都要建</p>
<p><a href="https://www.luogu.com.cn/problem/P1346">电车</a><br>
<font color = yellow><strong>普及/提高-</strong></font><br>
题目中<strong>如果电车司机想走另一个轨道，他就必须下车切换开关的状态</strong>问最少下车几次，问题就转化为：对于任意一个路口，他可以花费0的代价到默认的路口，花费1的代价到其他路口，然后建图跑最短路就行</p>
<p><a href="https://www.luogu.com.cn/problem/P2661">[NOIP2015 提高组] 信息传递</a><br>
<font color = yellow><strong>普及/提高-</strong></font><br>
题目中，游戏的结束定义为<strong>有人从别人口中得知自己的生日</strong>如果我们把一个信息看成一个节点，每个人为一棵树，每次传递信息就是合并两棵树，那么结束条件相当于<strong>有人的子节点为自己</strong>就是一个<strong>环</strong>的情况，可以进行的轮数就是<strong>图中最小环的长度</strong>，这道题只需要每次加一个点就建边，边加边做，然后如果i和t<sub>i</sub>的祖先不同，就更新深度与父节点，否则取min更新答案，最后输出最小长度就行</p>
<p><a href="https://www.luogu.com.cn/problem/P1283">平板涂色</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
一道状压题，我们设f[i][j] = x,表示状态为x时，最后一次刷j色用的最少次数，s 的二进制的从右往左数的第 i 位（1/0）代表了（是/否）涂了第i块， 如果颜色相同就直接刷，否则次数加一<br>
<img src="https://520cxy.github.io/post-images/1625197325448.png" alt="" loading="lazy"><br>
还有就是刷的时候需要判断限界条件<strong>一个矩形只能在所有紧靠它上方的矩形涂色后，才能涂色</strong>所以在转移状态的时候要check一下<img src="https://520cxy.github.io/post-images/1625197483250.png" alt="" loading="lazy"></p>
<p><font size=6><strong>7.5</strong>:</font><br>
<a href="https://www.luogu.com.cn/problem/P1525"> [NOIP2010 提高组] 关押罪犯</a><br>
<font color=green><strong>普及+/提高</strong></font><br>
先按危害从大到小排序，让危害大的罪犯在两个监狱里，那么，再结合敌人的敌人和自己在一个监狱的规律合并。当查找时发现其中两个罪犯不可避免地碰撞到一起时，只能将其输出并结束。没有冲突时一定输出0。</p>
<p><a href="https://www.luogu.com.cn/problem/P2103">道路值守</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
看到数据范围N&lt;=500又跟最短路有关，那么首先就想到了弗洛伊德，时间5s内真的是，多多有余。题意翻译过来就是问你<strong>任意两点的最短路有几条</strong>有点像这题<font color=green><a href="https://www.luogu.com.cn/problem/P1144">最短路计数</a></font><s>绿题对各位dalao来说很简单吧/kk</s>不过感觉算法难度要最短路计数难一点，这道能有蓝估计是因为细节处理的比较麻烦，注意以下事项：</p>
<blockquote>
<p>1.一开始弗洛伊德时，f[i][j]要初始化为原来的距离；<br>
2.g[i][i]和f[i][i]都为0；<br>
3.最后统计路径时要做完最短路以后统计，且枚举时要保证两点之间是直连的；<br>
4.枚举一个终点j，再枚举一个k，<strong>如果k在i-j的最短路上，那么s[k]个方案要全放在ans[i][j]里</strong></p>
</blockquote>
<p><a href="https://www.luogu.com.cn/problem/P1280">尼克的任务</a><br>
<font color=green><strong>普及+/提高</strong></font><br>
读入的时候，我们把当前时间点有任务就把任务放到改时间点内；<br>
设f[i]表示i~n的最大空闲时间，那么倒着推，对于每个i，我们只有有任务或没任务两种状态，如果有任务就取max，f[i]=max(f[i],f[i+t])，t为某一个任务的持续时间，如果没有任务就是上一个时间点+1,f[i] = f[i+1]+1;</p>
<p><a href="https://www.luogu.com.cn/problem/P5858">「SWTR-03」Golden Sword</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
对于每个状态，影响该状态的只有顺序和锅内原料数量有关，所以设f[i][j]表示放入第i个原料，锅内有j个原料时，所获得的最大耐久度，于是有f[i][j] = max(f[i][j], f[i-1][k])+j<em>a[i],<br>
其中j-1&lt;=k&lt;=min(m,j+s-1);但是这样的做法是O(nw<sup>2</sup>)的<br>
考虑到j</em>a<sub>i</sub>是个定值，所以方程又可以简化为<br>
f[i][j] = max(f[i][j], f[i-1][k])+a[i]*j<br>
然后max里的数据是可以用<strong>单调队列优化</strong>的</p>
<p><font size=6><strong>7.6 搜索、模拟专项</strong>:</font><br>
<a href="https://www.luogu.com.cn/problem/P1825"> [USACO11OPEN]Corn Maze S</a><br>
<font color=green><strong>普及+/提高</strong></font><br>
bfs裸题加上传送门的特殊判断就行，如果你在传送门就传送然后继续搜索</p>
<p><a href="https://www.luogu.com.cn/problem/P1074">[NOIP2009 提高组] 靶形数独</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
分别用三个数组存每一行每一列和每一九宫格中还需要填入的点<br>
s[ i ][0]与s[ i ][1]存点的坐标，s[ i ][2]存点的分值，s[ i ][3]存点的所在宫<br>
之后跑深搜模拟</p>
<p><a href="https://www.luogu.com.cn/problem/P1058">[NOIP2008 普及组] 立体图</a><br>
<font color = yellow><strong>普及/提高-</strong></font><br>
为了造成视觉覆盖效果，我们再覆盖的时候要严格按照从后往前，从下到上，从左到右的次序，首先我们需要确定输出的行数和列数，结论：每行要输出4m+2n+1个字符，而行数则由放入正方形的最大高度决定，不难发现，每往上累计一个方块，行数就要+4，由于位置(i,j)堆叠a[i][j]个立方体对高度的要求为高度至少为2(n-i)+3*a[i][j]+3，我们对每个位置求出这个值取max即可<br>
然后确定每个方块顶点的位置位于(i,j)的从下往上第x个立方体，它的右下角为(k-3(x-1)+2(n-i),4(j-1)+2(n-i)+1)，然后填充</p>
<p><a href="https://www.luogu.com.cn/problem/P2280">[HNOI2003]激光炸弹</a><br>
<font color=green><strong>普及+/提高</strong></font><br>
二维前缀和优化搜索枚举</p>
<p><a href="https://www.luogu.com.cn/problem/UVA532">UVA532 Dungeon Master</a><br>
<font color=green><strong>普及+/提高</strong></font><br>
暴力三维广搜</p>
<p><a href="https://codeforces.com/problemset/problem/1006/F">Xor-Paths</a><br>
<font color=purple><strong>省选/NOI-</strong></font><br>
思路：<strong>折半枚举</strong>，通过(1,1)dfs到(i,j)点的所有可能路径的所有结果，其中i+j=max(n,m),将所有在(i,j)的结果存储起来；<br>
反向枚举，从(n,m)dfs到(u,v)点的所有可能路径的结果，其中u+v=max(n,m)+1；<br>
然后从每一个(u,v)点开始匹配，根据结果枚举另一半可能结果，分别在(u-1,v)和(u,v-1)点上查找相应的结果，其中u-1+v=u+v-1=max(n,m),(u-1,v)和(u,v-1)点都是第一次dfs计算出来的结果</p>
<p><a href="https://vjudge.net/contest/445626#problem/K">数独</a><br>
<font color=purple><strong>省选/NOI-</strong></font><br>
调了一晚上，我吐了，主要要优化，用二进制标记位数是否被用过，然后这道题输出都有坑，<strong>没有解和多解情况都是输出“NO”</strong></p>
<p><a href="https://www.luogu.com.cn/problem/P4573"> [CQOI2013]新数独</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
先普通生成数独，然后再按照给出的大小关系修改即可</p>
<p><font size=6 color=red><strong>7.7 爆弹%你赛</strong>:</font><br>
<font color=red size=6><strong>牢记初心， 勿忘国耻</strong></font><br>
<a href="https://www.luogu.com.cn/problem/P3106">[USACO14OPEN]Dueling GPSs S</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
先按照两套不同的GPS系统跑最短路。然后最后跑出来的最短路的警告次数累计建图再反过来跑一遍最短路</p>
<p><a href="https://codeforces.com/problemset/problem/484/C">Strange Sorting</a><br>
<font color=purple><strong>省选/NOI-</strong></font><br>
抓住循环节，提前预处理出每个位置经过循环节后的位置就可以，我们用一个p数组表示一次操作数字的位置变化，把排序区间移动看成是数组整体左移，这样子我们只要变更一下pp数组，在用pp数组递推的同时考虑数组左移，就只要不停地对第一个区间进行排序即可。</p>
<p>read<br>
<font color=blue><strong>提高+/省选-</strong></font><br>
就是硬模拟</p>
<p>graph<br>
<font color=blue><strong>提高+/省选-</strong></font><br>
把一个方格看为一个点，先离线建图，然后如果两个点删边就合并，吧合并在一起的缩点，判断是否连通即可</p>
<p><font size=6><strong>7.8 动态规划，贪心专项</strong>:</font><br>
<a href="https://www.luogu.com.cn/problem/P5020"> [NOIP2018 提高组] 货币系统</a><br>
<font color=green><strong>普及+/提高</strong></font><br>
结论：对于两个等价的货币系统A和B（A&gt;B），我们看成两个集合，那么A中能被其他数组成的数肯定不在B中，A中不能被其它数组成的数一定在B中，然后定义f[i]表示数i是否能被其他数组成，做完全背包</p>
<p><a href="https://www.luogu.com.cn/problem/P4823"> [TJOI2013]拯救小矮人</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
对于每个小矮人，我们定义其<strong>逃生空间为H-a-b</strong>，显然逃生空间越小的越先要出去，不然后面就出不去了，所以先按逃生空间从大到小排序，之后我们定义f[i]表示走了i个小矮人之后其余小矮人组成的最高高度<img src="https://520cxy.github.io/post-images/1625711841865.png" alt="" loading="lazy">对于每个小矮人，我们选择让它走或者留下，显然能走的先走，如果走了j个人的高度f[j-1]加上自己的手长大于H，那么对于走了j个人的剩余最高高度就是max（走了j个人-自己的高度）</p>
<p><a href="https://www.luogu.com.cn/problem/P3959"> [NOIP2017 提高组] 宝藏</a><br>
<font color=purple><strong>省选/NOI-</strong></font><br>
<strong>深搜加剪枝</strong> 普通枚举深搜肯定过不了，我们把能优化的全部优化下。<br>
首先因为每个点总要扩展一条边，所以我们把最小的边找出来，是最优性剪枝，而且边权越小的最为解的可能性越大,然后在枚举的时候要把最优剪枝的影响去掉。之后深搜时，枚举扩展点最优性剪枝，如果当前解加上理论最小的费用都比中途的答案高那么这次搜索一定不是最优解，再重新标记回起点继续搜下去就行</p>
<p><font size=6><strong>7.9 动态规划，贪心专项</strong>:</font><br>
<a href="https://codeforces.com/problemset/problem/727/F">F. Polycarp's problems</a><br>
<font color=purple><strong>省选/NOI-</strong></font><br>
贪心维护一个大根堆。对于a[i]数组，你先倒序遍历，如果是负的就入堆，否则就把能抵消的负数给抵消，之后前缀和预处理区间，由于堆里存的都是负数，所以在计算前缀时要取反，这些负数取反后，从大到小排序的第i位代表了取到第i种答案，要删去1~i个数。二分查找即可</p>
<p><a href="https://www.luogu.com.cn/problem/P5664?contestId=46497">[CSP-S2019] Emiya 家今天的饭</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
这题哇，真的差点搞得我心态炸裂，这个题面我看了一上午，这个题解给了个状态转移方程但是没给状态定义，什么东西啊<br>
题意：给一个矩阵，从矩阵中取出k个数(k&gt;0)，每行只能取一个，每列的数最多取⌊2/k⌋个，有多少种方案<br>
输出所有方案数对998244353取模<br>
首先，很容易想到，维护每列选择节点的合法情况复杂度过高，<strong>用容斥的思想，我们反着做，那么合法方案数=总方案数-不合法方案数</strong>，总方案数输入的时候统计每行的总方案数在按乘法原理求就行，那么怎么求不合法方案数呢。<br>
明显的，有且仅有一列是不合法的，因为选取了k个数，不可能出现两列选取的数&gt;=k/2，我们就考虑枚举不合法的列，<strong>定义f[i][j][k]表示前i行选j个节点，当前列选了k个的方案数</strong>，这样可以获得84分的高分。考虑优化：我们可以发现对于j和k，并不需要存储取j或k个的方案数，我们所关心的只是j和k的大小关系，所以我们可以将后面两维压成一维，对于限制条件k&gt;⌊j/2⌋-&gt;2k+n-j&gt;n,n-j就是n行中没有选的行数（j表示前i行中选了j个，而每行只能选1个，所以选了j行），<strong>因此对于每个节点，选就等价于该列选两次，某一行若不选，等价于所有列选一次</strong>状态转移跟上面差不多，f[i][j]表示选了i行，当前列选了j个方案数<br>
<img src="https://520cxy.github.io/post-images/1625813809696.png" alt="" loading="lazy">不选当前列<br>
<img src="https://520cxy.github.io/post-images/1625813854236.png" alt="" loading="lazy">不选当前行<br>
<img src="https://520cxy.github.io/post-images/1625813886253.png" alt="" loading="lazy">选个当前点<br>
最后统计一列方案数大于n的即可</p>
<p><a href="https://www.luogu.com.cn/problem/P5023">[NOIP2018 提高组] 填数游戏</a><br>
<font color=purple><strong>省选/NOI-</strong></font><br>
<font color=red>打表找规律/kb</font></p>
<p><font size=6 ><strong>7.10 爆弹%你赛</strong>:</font><br>
T1：<br>
原题<a href="https://codeforces.com/problemset/problem/1110/E">Magic Stones</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
题意：给两个序列，问A序列操作后能否变为B序列<br>
每次操作可以选择一个i，(1&lt;i&lt;n)，将a<sub>i</sub>替换为a<sub>i-1</sub>+a<sub>i+1</sub>-a<sub>i</sub><br>
模拟后发现，<strong>每次操作就是交换了a<sub>i+1</sub>-a<sub>i</sub>和a<sub>i</sub>-a<sub>i-1</sub></strong><br>
于是先判首尾是否相同，然后判断差分数组是否相同即可</p>
<p>T2：<br>
<a href="https://codeforces.com/problemset/problem/1304/D"> Shortest and Longest LIS</a><br>
<font color=green><strong>普及+/提高</strong></font><br>
这题我真的想给自己一拳，/baojin/baojin/baojin<br>
以为自己只能拿部分分，也不知道怎么回事，数组就开了一部分，结果写出来是个正解！<br>
题意：<br>
给定序列每个元素的大小关系，构造两个序列分别是lis最大和最小；<br>
这题一个个插我不会，首先构造出升序排列(lis最大)和降序排列(lis最小)，在采用冒泡差不多的思想判断大小关系，如果不满足就交换两个元素，因为交换后可能之前的数就不满足大小关系所以哈还要回头判断</p>
<p>T3：<br>
<a href="https://codeforces.com/problemset/problem/1225/E">Rock Is Push</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
题意：<br>
二维平面上，有些格点上有箱子，可以推动箱子，且可以一次推动连续的直线上的箱子，但不能把箱子推到外面，问从起点（1，1）到（n，m）的方案数<br>
40分暴力：<br>
如果没箱子就是简单的递推，否则就深搜模拟，可以发现，推箱子就是把第一个箱子放到该方向上的第一个空位处，然后搜索下一个点再回溯就行</p>
<p>T4<br>
<a href="https://codeforces.com/problemset/problem/983/E">NN country</a><br>
<font color=purple><strong>省选/NOI-</strong></font><br>
链的情况：倍增跳跃，然后处理最短路</p>
<p><font size=6 color=green><strong>7.11</strong></font><br>
<font color=green><strong>THE NEXT.</strong></font></p>
<p><font size=6><strong>7.12 并查集+链表+堆</strong></font><br>
<a href="https://www.luogu.com.cn/problem/P1801">黑匣子</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
使用对顶堆，即一个大根堆和一个小根堆，若我们形象地将小根堆放到大根堆上面，并<strong>保证小根堆里的任何数都比大根堆里的数大</strong>，那么就会发现，<strong>这两推整体从上往下一次递减</strong>，然后每次把数加入大根堆，当大根堆的数量等于i时，就不断把大根堆的根移到小根堆里，因为整体是从上到下依次递减，所以意味着只要大根堆里的数有i个，那么意味着<strong>大根堆的顶处于整体的第i小</strong>，所以每次询问输出大根堆堆顶后，再把小根堆的根移到大根堆里，因为i+1了，要保证大根堆的数量为i（此时的i+1）</p>
<p><a href="https://www.luogu.com.cn/problem/P1196">[NOI2002] 银河英雄传说</a><br>
<font color=green><strong>普及+/提高</strong></font><br>
难点就是在于求距离定义一个数组d[]，d[i]表示i到他父节点的距离，那么一开始每个d[i]都为0，只需要<strong>在搜索其父节点时，将每个d[i]加上其父节点的d，即该节点到其父节点的距离加上其父节点到该父节点的父节点距离</strong>，所以当我们找到了一个点的祖先时也完成了更新其到祖先的距离，最后输出就是abs(d[x]-d[y])-1</p>
<p><a href="https://www.luogu.com.cn/problem/P3452"> [POI2007]BIU-Offices</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
<strong>求一个图补图的联通个数</strong>，首先我们按照原图建图，然后再用链表连接每个点，之后跑图枚举每个节点，如果是没标记过的就开一个联通块并放入队列，在链表里删掉这个点，然后枚举这个节点能够扩展的节点，只要扩展的节点是补图没跑过的就打标记，之后在链表上跑，跑到原图不能跑到的就标记并放入队列，在链表上删除该节点，跑完之后排序输出就行</p>
<p><a href="https://codeforces.com/problemset/problem/865/D">CF865D Buy Low Sell High</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
反悔贪心，把每个股票当成一个选项，然后放入小根堆，每次跟最小的比，受益最大的拿出就行</p>
<p><a href="http://codeforces.com/problemset/problem/449/C">CF449C Jzzhu and Apples</a><br>
<font color=purple><strong>省选/NOI-</strong></font><br>
质因数从大到小，偶数情况就匹配，技术情况就删除，保证最优</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我们毕业了]]></title>
        <id>https://520cxy.github.io/post/wo-men-bi-ye-liao/</id>
        <link href="https://520cxy.github.io/post/wo-men-bi-ye-liao/">
        </link>
        <updated>2021-06-25T05:13:01.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://520cxy.github.io/post-images/1624621129736.gif" alt="" loading="lazy"><br>
<font face = "楷体"> <center><br>
<font color = orange><font size=5>一张新拍的照片<br>
好像带给我一点点怀念<br>
食堂周围的那一片<br>
味道弥漫过铺满树叶的小院<br>
阳光透过树叶好像一丝一线<br>
夕阳照了一遍我眯着眼<br>
那张同桌寄的明信片<br>
安静的躺在课桌的里面<br>
快要过完的春天<br>
还有深绿破烂的窗帘<br>
窄窄的长长的过道两边<br>
双子大厦依然在抽着烟<br>
刚刚下完了小雨的季节<br>
体育课不知调到第几节<br>
记不得哪年的哪一天<br>
很漫长又很短暂的岁月<br>
现在已经回不去<br>
早已流逝的光阴<br>
校牌里的那一张渐渐模糊不清的丑照<br>
成了回忆的信号<br>
忘不掉的是什么我也不知道<br>
想不起当年模样<br>
看也看不到 去也去不了的地方<br>
也许那课间的嬉笑是属于我们的忧伤<br>
嘴角那点微笑越来越勉强<br>
忘不掉的是什么我也不知道<br>
放不下熟悉片段<br>
回头望一眼 仿佛很多年的时间<br>
透过手指间看着天<br>
我又回到那教室一间间<br>
靠在你们身边渐行渐远</font></font></center></font><br>
<font face = "楷体">                       致敬----------------18.9.1~21.6.25</font></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SOL_加工生产调度]]></title>
        <id>https://520cxy.github.io/post/sol_-jia-gong-sheng-chan-diao-du/</id>
        <link href="https://520cxy.github.io/post/sol_-jia-gong-sheng-chan-diao-du/">
        </link>
        <updated>2021-06-15T07:23:34.000Z</updated>
        <content type="html"><![CDATA[<p><font size=2 color=green><s>突然想起来我还有博客</s>大雾</font><br>
<a href="https://www.luogu.com.cn/problem/P1248">题面传送门</a><br>
<font size=6 color=blue>1.问题分析</font><br>
根据题面的描述，不同的加工顺序，加工完机器所需零件不同<br>
例如：现在有3个机器零件{J<sub>1</sub>, J<sub>2</sub>, J<sub>3</sub>}, 在第一台机器上加工时间分别为2、5、4，在第二台机器上加工时间分别为3、1、6<br>
<font color=brown size=4>(1)如果按照{J<sub>1</sub>, J<sub>2</sub>, J<sub>3</sub>}的顺序加工</font><br>
如下图所示：<br>
<img src="https://520cxy.github.io/post-images/1623743000390.png" alt="" loading="lazy"><br>
J<sub>11</sub>、J<sub>21</sub>、J<sub>31</sub>分别表示第1、2、3个零件在第一台机器上的加工时间。J<sub>12</sub>、J<sub>22</sub>、J<sub>32</sub>分别表示第1、2、3个零件在第二台机器上的加工时间。<br>
第一台机器先加工第1个零件，需要加工的时间为J<sub>11</sub>=2,t=2时结束，交给第二台机器加工，此时第二台机器储蓄空闲状态，需要加工时间为J<sub>12</sub>=3,t=5时结束，这时第二台机器处于空闲状态，等待第2个零件在第一台机器上下线<br>
第一台机器接着加工第2个零件，需要J<sub>21</sub>=5, t=7时结束，交给第二台机器加工，此时第二台机器处于空闲状态，需要加工时间为J<sub>22</sub>=1,t=8时结束，这时第二台机器处于空闲状态，等待第3个零件在第一台机器上下线<br>
第一台机器接着加工第3个零件，需要J<sub>31</sub>=4,t=11时结束，交给第二台机器加工，此时第二台机器处于空闲状态，需要加工时间为J<sub>32</sub>=6,t=17时结束<br>
<font color=red>我们得到t<sub>1</sub>=17</font><br>
<font color=brown size=4>(2)如果按照{J<sub>1</sub>, J<sub>3</sub>, J<sub>2</sub>}的顺序加工</font><br>
如下图所示：<br>
<img src="https://520cxy.github.io/post-images/1623744295684.png" alt="" loading="lazy"><br>
第一台机器先加工第1个零件，需要加工时间为J<sub>11</sub>=2,t=2时结束，交给第二台机器加工，此时第二台机器处于空闲状态，需要加工时间为J<sub>12</sub>=3,t=5时结束，此时第二台机器处于空闲状态，等待第3个零件在第一台机器上下线<br>
第一台机器接着加工第3个零件，需要J<sub>31</sub>=4,t=6时结束，交给第二台机器加工，此时第二台机器处于空闲状态，需要加工时间为J<sub>32</sub>=6,t=12时结束<br>
第一台机器接着加工第2个零件需要J<sub>21</sub>=5,t=11时结束，交给第二台机器加工，此时第二台机器处于繁忙状态，需要等待其空闲下来，t=12时才能加工，加工时间为J<sub>22</sub>=1,t=13时结束<br>
<font color=red>我们得到t<sub>2</sub>=13</font>,显然比第一种更优</p>
<p>我们可以得出一个有趣的现象：第一台机器可以连续加工，而第二台机器开始加工的时间是<font color=red><strong>当前第一台机器的下线时间和第二台机器下线时间的最大值</strong></font>就是图中连线的两个数值的最大值</p>
<p>3个机器零件有多少种加工顺序呢？即3个机器零件的全排列，共6种：<br>
1 2 3； 1 3 2； 2 1 3； 2 3 1； 3 2 1； 3 1 2；<br>
而我们的目的就是找到其中一个加工顺序，使得总加工时间最短<br>
实际上就是找到n个机器零件的一个排列，n个机器零件共有n！种排列，每个排列都是一种可行解。解空间是一棵排列树，如下图<br>
<img src="https://520cxy.github.io/post-images/1623748899996.png" alt="" loading="lazy"><br>
例如3个机器零件的解空间树，如下图<br>
<img src="https://520cxy.github.io/post-images/1623749495559.png" alt="" loading="lazy"><br>
从根到叶子的路径就是机器加工的一个加工顺序，如最右侧的（3，1，2），然后定义限界函数求最优解</p>
<p><font size=6 color=blue>2.算法设计</font><br>
<font color=brown size=4>(1)定义问题的解空间</font><br>
机器零件加工问题解的形式为n元组：{x<sub>1</sub>, x<sub>2</sub>,..., x<sub>i</sub>,..., x<sub>n</sub>}。分量x表示第i个加工的零件号n个零件做成的集合为S={1， 2， …， n}, x<sub>i</sub>的取值为S-{x<sub>1</sub>, x<sub>2</sub>,..., x<sub>i-1</sub>}， i=1, 2, ..., n<br>
<font color=brown size=4>(2)解空间的组织结构</font><br>
就是一棵排列树，如图<br>
<img src="https://520cxy.github.io/post-images/1623750346102.png" alt="" loading="lazy"><br>
<font color=brown size=4>(3)搜索解空间</font><br>
● <font color=black>约束条件</font><br>
由于任何一种零件加工次序不存在无法调度的情况，均是合法的。因此，任何一个排列都表示为问题的一个可行解，故不需要约束条件<br>
● <font color=black>限界条件</font><br>
用f<sub>2</sub>表示当前已完成的零件在第二台机器加工所用的时间，用bestf表示当前找到的最优加工方案的完成时间。显然，继续向深处搜索时，f<sub>2</sub>不会减少，只会增加。因此当f<sub>2</sub>⩾bestf时，就没有继续向深处搜索的必要。限界条件可以描述为：f<sub>2</sub>&lt;bestf, f<sub>2</sub>的初值为0，bestf的初值为无穷大。<br>
● <font color=black>搜索过程</font><br>
扩展结点沿着某个分支扩展时需要判断限界条件，如果满足，就进入深一层继续搜索；如果不满足，就剪掉该分支。搜索到叶子结点时，就找到当前最优解。搜索直到全部的活结点变成死节点为止。</p>
<p><font size=6 color=blue>3.完美图解</font><br>
例子跟一开始的一个鸭子，现在有3个机器零件{J<sub>1</sub>, J<sub>2</sub>, J<sub>3</sub>}, 在第一台机器上加工时间分别为2、5、4，在第二台机器上加工时间分别为3、1、6。f<sub>1</sub>表示当前第一台机器上加工的完成时间，f<sub>2</sub>表示当前第二台机器上加工的完成时间。<br>
<font size=4 color=brown>（1）开始搜索第一层(t=1)</font><br>
扩展A结点的分支x<sub>1</sub>=1,f<sub>2</sub>=5,bestf的初值为无穷大，f<sub>2</sub>&lt; bestf，满足限界条件，令x[1]=1，生成B结点<br>
<img src="https://520cxy.github.io/post-images/1623803034925.png" alt="" loading="lazy"><br>
<font size=4 color=brown>（2）扩展B结点(t=2)</font><br>
扩展B结点的分支x<sub>2</sub>=2, f<sub>2</sub>=8,bestf初值为无穷大，满足限界条件，令x[2]=2，生成C结点<br>
<img src="https://520cxy.github.io/post-images/1623804450415.png" alt="" loading="lazy"><br>
<font size=4 color=brown>（3）扩展C结点(t=3)</font></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP分析]]></title>
        <id>https://520cxy.github.io/post/dp-fen-xi/</id>
        <link href="https://520cxy.github.io/post/dp-fen-xi/">
        </link>
        <updated>2021-04-19T05:43:59.000Z</updated>
        <content type="html"><![CDATA[<p><font size=6 color=red>1.为什么做dp要分析：</font><br>
比如，我们在计算123x456时，会使用竖式计算<s>你牛你口算</s>，<br>
<img src="https://520cxy.github.io/post-images/1618811515575.png" alt="" loading="lazy"><br>
但是要是我们口算234x567，对于我这种蒟蒻肯定是很困难的。<br>
那么做dp题目的时候也一样，很多时候我们做dp题目喜欢干瞪眼看， 确信。然后就空想，不动笔不动纸，那么这样情况下就白白给自己增加了很多难度。<font color=green>那么dp分析法，就是相当于乘法列竖式一样的一个使解决问题思路清晰的方式</font></p>
<p><font size=6 color=red>2.核心</font><br>
<font color=red>核心就是从集合的角度来分析dp问题</font><br>
回想我们之前做过的dp问题， 我们发现都是<font color=red>有限集内最优化、最值问题</font><br>
由于大多问题集内元素个数都为指数级，所以枚举运算起来的时间复杂度很高，因此我们要用dp优化</p>
<p><font color=red size=6>3.为什么dp可以优化这些问题</font><br>
<font color=green>dp过程中，要经历两个阶段</font><br>
<font color=blue size=5>阶段一：化零为整，即状态表示</font><br>
我们每次在处理问题时，不是一个方案一个方案，一个元素一个元素枚举，而是每次枚举一堆元素、枚举一个子集、枚举一类东西， 就是<font color=red>把一些有着相似性质的东西化为一个子集，用某个状态来表示， 就是化零为整的过程</font>。</p>
<p><font color=green>状态表示里我们一般要从两个角度分析</font>，，<br>
<font size=4 color=purple>第一个角度：</font><br>
我们的状态，比如f[i]，要考虑f[i]表示的是哪个集合，就是集合是什么。那么这个集合一般表述的方式就是：<font color=red>所有满足XXX条件的方案的集合。</font>正因为f[i]表示的是一类东西，所以枚举f[i]可以优化</p>
<p><font size=4 color=purple>第二个角度：</font><br>
第二个要考虑的就是f[i]虽然表示的是一个集合，但是存入数组的是一个数字或bool值。那么<font color=red>这个数和这个集合的关系，我们称为属性</font>，说白了就是我们这个集合存的是什么东西，<font color="#00dddd">属性一般有三种：maxn，minn，count</font></p>
<p><font color=blue size=5>阶段二：化整为零， 即状态计算</font><br>
与阶段一相反，这个等等举例。那么怎么去做？<font color=red>先看f[i]表示的所有状态是什么，然后把整个状态里看成一个集合，那么求f[i]就需要把整个集合划分为若干个子集。</font><br>
<img src="https://520cxy.github.io/post-images/1618814570057.png" alt="" loading="lazy"><br>
这些子集一般又符合两个原则；<br>
<font color=pink>原则一，不重复：</font>就是每个元素是单独属于其中一个子集；<br>
<font color=pink>原则二，不遗漏：</font>就是所有子集并集的元素一定把f[i]集合中所有元素都包含了。<br>
这时我们要求f[i]就是要求每个子集的值。<font color="#00dddd">比如我们现在f[i]的属性是最大值，那么整个集合最大值是什么，就是我们每个子集的最大值再取一个最大值；如果f[i]的属性是数量，那么整个集合的数量就是所有子集的数量之和。</font><br>
所以我们把<font color=red>整个集合的问题划分为若干个子集的小问题，我们去处理每个子集，再把每个子集计算后的结果整理得出f[i]的值，就是一个化整为零的过程</font>；<br>
有个要注意的地方，就是上面子集划分的两个原则，并不是一定所以情况下都要满足，首先不遗漏很清楚，要满足的，<font color=red>但是不重复需要注意：当我们求数量的时候，我们必须要满足不重复。但是当我们求最值的时候，其实可以重复，这点利用传递性很好理解，就是计算多了。</font></p>
<p>然后集合划分，我们一般也有个套路，我们一般是怎么去划分这个集合呢？<br>
<font color=red>划分依据：找最后一个不同点。</font></p>
<p>在找递推式子的时候，我们一般先假设我们已经求出了答案，顺藤摸瓜，就能更好地划分每个状态</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原根代码及优化]]></title>
        <id>https://520cxy.github.io/post/yuan-gen-dai-ma-ji-you-hua/</id>
        <link href="https://520cxy.github.io/post/yuan-gen-dai-ma-ji-you-hua/">
        </link>
        <updated>2021-04-13T10:59:10.000Z</updated>
        <content type="html"><![CDATA[<p><font color=green size=5><strong>CODE</strong></font><br>
<img src="https://520cxy.github.io/post-images/1619069324790.png" alt="" loading="lazy"><br>
<img src="https://520cxy.github.io/post-images/1619069332113.png" alt="" loading="lazy"><br>
这是最常用的方法<br>
如果你还想要更优的复杂度：<br>
删去<br>
<img src="https://520cxy.github.io/post-images/1619069374435.png" alt="" loading="lazy"><br>
加上<br>
<img src="https://520cxy.github.io/post-images/1619069410903.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="1"><img src="https://520cxy.github.io/post-images/1619069561433.png" alt="" loading="lazy"></figure>
<p>还有更快的！！！<br>
现在发现瓶颈在枚举的数量上，其实还可以优化<br>
有一个结论：设φ ( m ) = p<sub>1</sub><sup>a<sub>1</sub></sup> * p<sub>2</sub><sup>a<sub>2</sub></sup> * ... * p<sub>n</sub><sup>a<sub>n</sub></sup><br>
那么只需要判断：<img src="https://520cxy.github.io/post-images/1618471759699.png" alt="" loading="lazy"><br>
如果有一个条件满足，那么当前的g一定不是原根如果对于一个φ(m)的因数b满足了条件，那么在这些数当中一定至少有一个也满足这个条件，然后就好啦<br>
代码依然用替换来给出，替换上文提到的地方<br>
<img src="https://520cxy.github.io/post-images/1619069458700.png" alt="" loading="lazy"><br>
<img src="https://520cxy.github.io/post-images/1619069496529.png" alt="" loading="lazy"><br>
完结撒花</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4.5 Solution]]></title>
        <id>https://520cxy.github.io/post/45-solution/</id>
        <link href="https://520cxy.github.io/post/45-solution/">
        </link>
        <updated>2021-04-05T06:46:08.000Z</updated>
        <content type="html"><![CDATA[<p><font size=6>T1:纯粹理性批判</font><br>
<font size=4>题目描述：</font><br>
<img src="https://520cxy.github.io/post-images/1617605412575.png" alt="" loading="lazy"><br>
样例输入：10<br>
样例输出：21<br>
<font size=4>方法：</font><br>
我们将所有a, b的情况分为三类 ：<br>
<font color=green>1. a = b 时</font>， 显然不可能(自己举栗子)<br>
<font color=green>2. a &gt; b 时</font>， 此时<font color=blue>b/a = 0</font> 要满足a%b = 0， 则<font color=red>所求二元组为b是a的因子</font><br>
<font color=green>3. a &lt; b 时</font>，此时<font color=blue>a%b = a</font> 要满足b/a=a， 则<font color=red>所求二元组数为区间数量a<sup>2</sup> &lt; b &lt; a<sup>2</sup>+a</font><br>
然后统计答案</p>
<p><font size=6>T2:自我救赎</font><br>
<font size=4>题目描述：</font><br>
<img src="https://520cxy.github.io/post-images/1617607036161.png" alt="" loading="lazy"><br>
样例输入:<br>
5<br>
5 4 3 2 1<br>
样例输出:<br>
4<br>
<font size=4>方法：</font></p>
<blockquote>
<p>数据太水O(n<sup>2</sup>)暴力枚举，只要往后扫，一碰到比它大的就++，break，直接过</p>
</blockquote>
<p><font size=6>T4:失乐园</font><br>
<font size=4>题目描述：</font><br>
<img src="https://520cxy.github.io/post-images/1617607354812.png" alt="" loading="lazy"><br>
样例输入：<br>
8<br>
20152016<br>
样例输出：<br>
4<br>
样例解释：<br>
”20152016” = ”20152016”<br>
”20152016” = ”20” + ”152016”<br>
”20152016” = ”201” + ”52016”<br>
”20152016” = ”2015” + ”2016”</p>
<p><font size=4>方法：</font><br>
<font color=red>区间DP</font>，<br>
但是要先做一个LCP（最长公共前缀）优化<s>我不会</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4.2 Solution]]></title>
        <id>https://520cxy.github.io/post/42-solution/</id>
        <link href="https://520cxy.github.io/post/42-solution/">
        </link>
        <updated>2021-04-02T02:04:33.000Z</updated>
        <content type="html"><![CDATA[<p><font size=5>T1 生成字符串</font><br>
在模拟的时候发现，如果他给出了<font color=red>连续的n个T<sub>1</sub>操作，就是翻转n%2次</font>，而串首串尾加字符，如果加了以后翻转，就等价于反着加，我们只需要记下每次操作填补的位置最后进行操作就行；</p>
<p><font size=5>T2 字符串查询</font><br>
据dalao们说是线段树和树状数组的维护，<s>我也看出来了</s>，但是我没<s>马</s>码；</p>
<p><font size=5>T3 下取整</font><br>
只要按照题目描述的进行操作之后，存下来的数和原数比较，反正我是做了一遍<font color=red>数学的逆运算</font>就切了唔</p>
<p><font size=5>T4 整除</font><br>
原题：<a href="https://atcoder.jp/contests/abc158/tasks/abc158_e">ABC158 E - Divisible Substring</a><br>
思维题，有一个很特别的性质吧，我也不知道叫什么，<font color=red>比如你的s[i]%p=k, s[j]%p=k,那么，<img src="https://520cxy.github.io/post-images/1617330955337.png" alt="" loading="lazy"></font><br>
<font color=green>所以在区间[i, j]中的数都能取，之后统计i~j中所有区间长度的区间个数累计加起来</font><br>
还有就是要注意p=2, 5的情况需要特判，由于这俩很好判断，<font color=red>只要末尾上的数可以整除那么前面一系列数都能取</font></p>
<p><font size=5>T5 机器人</font><br>
原题：<a href="https://atcoder.jp/contests/abc158/tasks/abc158_f">ABC158 F - Removing Robots</a><br>
首先这是一个DAG模型，一个机器的激活可以引起另一个的激活，这样我们根据某一机器人向能够引起爆炸的另外一个机器人连边便可以得到一张<font color=red>有向无环图</font><br>
事实上，有向无环图我们很难建立而且很难在上面完成答案的计算；<br>
因此题解中有一个很妙的思路：</p>
<blockquote>
<p>将DAG中多余的边去掉，使其变成一个树结构<br>
我们将<strong>多于的边去掉首先需要保证的是不会影响答案的计算</strong></p>
</blockquote>
<p>例如(A,B),(B,C),(A,C)这三条边中我们完全可以将(A,C)去掉，因为这两条路径是等价的。<br>
因此我们对于每一节点，只需要<font color=red>向离节点最左边位置的节点连边</font>即可。<br>
在程序实现上，我们可以使用优先队列/栈来维护：<br>
我们反向考虑，对于没有受到连边的节点放到一个容器使得容器的顶部位置最小。<br>
（为了能更容易的得到连边）<br>
若当前可以向容器的顶部连边，则连边并弹出顶部，直到不能连边为止。<br>
<font color=green>最优我们得到了一个森林结构，我们以每一个根为起点做树形DP。<br>
DP很很好写——xhf dalao</font><br>
我们设f[i]表示以i为根子树的选择方案。<br>
当i启动时，子树都需要启动，方案为1。<br>
当i不启动时，方案为子树的f值得积<br>
最后的答案是森林中每一个根的f值之积。<br>
<img src="https://520cxy.github.io/post-images/1617330304397.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一些数学芝士]]></title>
        <id>https://520cxy.github.io/post/yi-xie-shu-xue-zhi-shi/</id>
        <link href="https://520cxy.github.io/post/yi-xie-shu-xue-zhi-shi/">
        </link>
        <updated>2021-04-01T06:34:13.000Z</updated>
        <content type="html"><![CDATA[<p><font size=6 color=red></font><br>
<font size=6 color=purple>前置芝士</font></p>
<blockquote>
<p>1.阶：若a, p互质, 使a<sup>l</sup> % p==1,的最小正整数l定义为a模p意义下的阶, 记作ord<sub>p</sub> a；<br>
2.欧拉函数：给出一个正整数x，函数值np定义为0~x内与x互质的数的个数，记作φ(x)=n<br>
3.欧拉定理：a<sup>φ(p)</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span></span></span></span> 1(mod p)</p>
</blockquote>
<p><font size=6 color=red >原根：</font><br>
<font size=4 color=blue>定义：</font></p>
<blockquote>
<p>那么<font color=red>若ord<sub>p</sub>a=φ(p), 则称a是模p意义下的原根，归根到底就是g<sup>(P-1)</sup> = 1 (mod P)当且仅当指数为P-1的时候成立。(这里P是素数)。</font></p>
</blockquote>
<p><font size=4 color=blue>求法:</font><br>
1.<strong>暴力求解</strong>：<br>
求n的原根时，由于原根都比较小，所以我们可以将原根g从2开始枚举，判断ord<sub>n</sub> g == φ(n)?代码就不放了<br>
2.<strong>稍快的方法</strong>：<br>
上一个暴力的复杂度就是φ(m)*log(m)*O(g)，笑死了，在大质数的时候完全跑不动，这是oiers所不能接受的<s>要快！</s>。<br>
容易发现：我们在枚举g的时候只要枚举与m互质的数，若不互质，那么一定不满足一一对应的条件<br>
不过很多情况下我们要求的都是一个质数的原根，所以这个优化不常用（噗呲<br>
3.<strong>更快的方法！</strong><br>
在上面的代码中枚举i时发现：i不是每个都有用的。给出一个<s>玄学的</s>结论：<font color=red>枚举i只需要枚举φ(m)的因数就好了</font>证明：不会，自己问度娘。<br>
代码：在专篇里<br>
一般这个方法就够了复杂度就O(m)+O( m)∗O(logm)∗O(g)<br>
还有更优化方法，也在专篇里，这里就不放了，内容有点小多TwT</p>
<p><font size=6 color=red>扩展欧拉定理：</font><br>
<font color=green><s>oiers</s>我从来都只记结论，不会证明。确信</font><br>
<a href="https://www.luogu.com.cn/problem/P5091">例题</a><br>
求a<sup>c</sup> mod m<br>
显然，由于m和c会非常大，一般方法肯定不行<br>
于是，扩展欧拉定理诞生了！！！<br>
<font color=red>若gcd(a, m) == 1</font> ，即底数与模数互质时，根据欧拉定理<br>
<img src="https://520cxy.github.io/post-images/1618299104331.png" alt="" loading="lazy"><br>
<font color=red>若gcd(a, m) != 1 &amp;&amp; c&lt;φ(m)</font>，<s>根据扩展欧拉定理</s><br>
<img src="https://520cxy.github.io/post-images/1618299216215.png" alt="" loading="lazy"><br>
<font color=red>若gcd(a, m) != 1 &amp;&amp; c≥φ(m)时</font> 根据扩展欧拉定理：<br>
<img src="https://520cxy.github.io/post-images/1618299283790.png" alt="" loading="lazy"><br>
那么：<font size=4 color=green>馬媽再也不用担心指数爆炸啦，因为指数也能取模啦！！！</font></p>
<p><font size=6 color=red>二次剩余和N次剩余</font><br>
<font size=5 color=blue>二次剩余</font><br>
<a href="https://www.luogu.com.cn/problem/P5491">例题</a><br>
求解同余式<img src="https://520cxy.github.io/post-images/1619308559461.png" alt="" loading="lazy"><br>
若同余式有解，我们称x是a模p意义下的二次剩余；若无解，我们称x是a模p意义下的非二次剩余<br>
<strong>定理一：对于所求的二次同余式， 有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo></mrow><annotation encoding="application/x-tex">\lfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{p-1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.242216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.897216em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">⌋</span></span></span></span>个不同的解</strong><br>
<strong>定理二：若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mo>(</mo><mi>p</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">mod(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span>, p=p<sub>1</sub>p<sub>2</sub>.....p<sub>k</sub>，则有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> mod(p<sub>1</sub>),<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> mod(p<sub>2</sub>)......<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> mod(p<sub>k</sub>)</strong></p>
<p>引入<a href="https://en.wikipedia.org/wiki/Euler%27s_criterion">欧拉准则</a><br>
这是一个用来判定的经典准则（其实勒让德符号的定义准确来说就是从这里定义的）<br>
这里规定，当模数为奇素数的时候···（此处省略解释）<br>
直接代入勒让德符号成为<br>
<img src="https://520cxy.github.io/post-images/1619311696838.png" alt="" loading="lazy"></p>
<p>对于判定模数为奇素数时，我们定义勒让德符号<br>
<img src="https://520cxy.github.io/post-images/1619311092988.png" alt="" loading="lazy"><br>
现在我们已经会判定了!!!tql!!!但是我们更多的是求这个值<s>大雾</s><br>
假设我们已经判断完了，发现a是模p的二次剩余，那么其他的解也可以通过该解计算得出。</p>
]]></content>
    </entry>
</feed>