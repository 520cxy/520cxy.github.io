<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://520cxy.github.io</id>
    <title>LL.的小窝</title>
    <updated>2021-07-03T06:22:47.654Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://520cxy.github.io"/>
    <link rel="self" href="https://520cxy.github.io/atom.xml"/>
    <subtitle>共道人间惆怅事,不知今夕是何年 ——《周秦行纪》</subtitle>
    <logo>https://520cxy.github.io/images/avatar.png</logo>
    <icon>https://520cxy.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, LL.的小窝</rights>
    <entry>
        <title type="html"><![CDATA[灯泡！打牌！大炮！]]></title>
        <id>https://520cxy.github.io/post/deng-pao-da-pai-da-pao/</id>
        <link href="https://520cxy.github.io/post/deng-pao-da-pai-da-pao/">
        </link>
        <updated>2021-07-02T12:28:40.000Z</updated>
        <content type="html"><![CDATA[<p>the shy告诉我dp联赛要一直考到状压，然后我想起来我dp一直不咋行，这可咋整<br>
<font size=6><strong>区间DP</strong></font></p>
<p><font size = 5>朴素模板O（n<sup>3</sup>）</font><br>
<img src="https://520cxy.github.io/post-images/1625291612126.png" alt="" loading="lazy"><br>
例题：<a href="https://vjudge.net/problem/51Nod-1021">石子合并easy</a></p>
<p><font size=5>题目变形，<strong>线性变环状</strong></font><br>
思路：环状以后合并区间的情况就可以从后往前合并，最后合并完成可能是1<sub>n,2</sub>n<sub>1,3</sub>n~2.....这种n个石子合并的情况。所以我们可以破环成链，将前n-1各元素也放到n后面构成一个线性的环状序列，在对这个序列dp即可<br>
例题：<a href="https://www.luogu.com.cn/problem/P1880">[NOI1995] 石子合并</a><br>
大体思路与原题差不多，就是处理的时候前缀和在n后要接上1，2，3...然后状态转移时，起点要一直枚举到2*n，最后取最值时，枚举起点i从1~n，取f[i][n+i-1]要<strong>取一圈</strong></p>
<p><font size=5>时间优化 <strong>四边形优化O(n<sup>2</sup>)</strong></font><br>
思路：在查找最优分割点的时候，我们浪费了大量时间。那么我们可以把最优分割点保存下来，在查找的时候利用保存的最优分割点来优化查找过程。<br>
四边形不等式优化：<br>
（1）功能：用来寻找，s[i][j](i~j的最优分割点）与其他分割点的关系<br>
（2）不等式内容：如果某东西满足a&lt;b&lt;=c&lt;d且f[a][c]+f[b][d]&lt;=f[a][d]+f[b][c],则说这个东西满足四边形不等式。简而言之：交叉小于包含！<br>
（3）结论关系：s[i][j-1]&lt;=s[i][j]&lt;=s[i+1][j]<br>
（4）证明过程：<br>
0.证明w满足四边形不等式，这里w是m的附属量，形如m[i,j]=opt{m[i,k]+m[k,j]+w[i,j]}，此时大多要先证明w满足条件才能进一步证明m满足条件<br>
1.证明m满足四边形不等式<br>
2.证明s[i,j-1]≤s[i,j]≤s[i+1,j]<br>
<img src="https://520cxy.github.io/post-images/1625270269425.png" alt="" loading="lazy"><br>
结论关系：s[i][j-1]&lt;=s[i][j]&lt;=s[i+1][j]<br>
<img src="https://520cxy.github.io/post-images/1625270776603.png" alt="" loading="lazy"><br>
<a href="https://blog.csdn.net/noiau/article/details/72514812">证明详解</a><br>
<img src="https://520cxy.github.io/post-images/1625282987592.png" alt="" loading="lazy"><br>
例题<a href="http://poj.org/problem?id=2955">Brackets</a><br>
如果两个括号匹配，那么它的状态就是<strong>该匹配成功的括号内的区间左右长度状态+2</strong>然后按照朴素方法做输出就行<br>
if(s[i] 与 s[j]匹配） dp[i][j] = d[[i+1][j-1] +2;<br>
dp[i][j] = max(dp[i][j],dp[i][k]+dp[k+1][j]);</p>
<p><a href="http://poj.org/problem?id=1651">Multiplication Puzzle</a><br>
因为最后都要删掉中间所有的数字，所以我们分隔一个个小区间删数字，合并区间求最小。那么我们的状态就是目前删掉的数字区间，但是我们分割的时候的意思是抽一个卡片出来，所以这个卡片不能在已经抽出的状态里面，所以dp[i][j]里面是不包含j卡片的！<br>
状态转移方程：dp[i][j]表示抽出第i~j-1张卡片时候的最小值<br>
dp[i][j] = min(dp[i][j],dp[i][k] + dp[k+1][j] +num[i-1]*num[k]*num[j]);</p>
<p>整数划分（四）<br>
（1）题意：给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积<br>
（2）思路：这里给的乘号是有限个，所以状态方程里必须包含使用乘号的个数，此外还要包含区间长度。所以怎么用二维dp实现包含m和n，我们可以用dp[i][j]表示在第1~i个字符里插入j个乘号的最大值。<br>
（3）状态转移方程 dp[i][j]表示在第1<sub>i个字符里插入j个乘号的最大值；用num[i][j]表示第i</sub>j个字符表示的数字；<br>
dp[i][j] = max(dp[i][j],dp[k][j-1]*num[k+1][i])</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4632">Palindrome subsequence</a><br>
(1)题意：给你一个字符串，求出其最多的可构成的回文字串（不要求连续），注：这里不同的回文字串只要求位置不同即可视为不同，如：aaaaa 的最多回文子串数目是 31.</p>
<p>（2）思路：用dp[i][j]表示状态，表示i~j里最多的回文字串数目，假设现在我们要求dp[i][j]：</p>
<p>a.首先：由前一个状态知：dp[i][j] = dp[i+1][j]并上dp[i][j-1] （因为区间尽可能大而且状态要在dp[i][j]之前，而且回文子串不要求 连续），由容斥原理得：dp[i+1][j] U dp[i][j-1] = dp[i+1][j]+dp[i][j-1] - dp[i+1][j] n dp[i][j-1]= dp[i+1[j]+dp[i][j-1] - dp[i+1][j-1]<br>
注意：这是一个固定的状态，每一个状态都由这个公式推出初始状态，是必须的，不是可选择地<br>
b.其次：如果s[i] == s[j] ,那么两端单独就可以构成回文子序列，而且与dp[i+1][j],dp[i][j-1],dp[i+1][j-1]，中的回文序列又可以构成新的回文序列，所以此时dp[i][j] = dp[i+1][j] U dp[i][j-1] + dp[i+1][j-1] +1;而dp[i][j]已经更新为 dp[i+1][j] U dp[i][j-1]，所以dp[i][j] = dp[i][j] + dp[i+1][j-1] +1;<br>
(3)状态转移方程： dp[i][j]表示i~j内最多的回文字串数目<br>
dp[i][j] = dp[i+1][j]+dp[i][j-1] -dp[i+1][j-1] (容斥）<br>
if(s[i] == s[j]) dp[i][j] = dp[i][j] +dp[i+1][j-1] +1; （思维）<br>
注：这里因为容斥时有减法，所以要先加上模再取模，要不会出现负数！</p>
<p><font size=6><strong>背包DP</strong></font><br>
<font size=5>01背包</font><br>
该问题特点：每种物品只有一件，决策为放或不放，我们设子问题诶状态f[i][j]表示前i件物品放到容量为j的背包中的最大价值，那么对于一件物品i，代价w[i],价值v[i],<br>
<img src="https://520cxy.github.io/post-images/1625281778957.png" alt="" loading="lazy"><br>
该方法为最朴素的算法<strong>O(VN)</strong><br>
<font size=4><strong>空间优化</strong></font><br>
先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1...N，每次算出来二维数组f[i][0...V]的所有值。那么，如果只用一个数组f[0...V]，能不能保证第i次循环结束后f[j]中表示的就是我们定义的状态f[i][j]呢？f[i][j]是由f[i−1][j]和f[i−1][j−w[i]]两个子问题递推而来，能否保证在推f[i][j]时（也即在第i次主循环中推f[j]时）能够得到f[i−1][j]和f[i−1][j−w[i]]的值呢？事实上，这要求在每次主循环中我们以j=V...0的顺序推f[j]，这样才能保证推f[j]时f[j−w[i]]保存的是状态f[i−1][j−w[i]]的值。至于为什么下面有详细解释。代码如下：<br>
<img src="https://520cxy.github.io/post-images/1625282679127.png" alt="" loading="lazy"><br>
其中的f[j]=max(f[j],f[j−w[i]])一句恰就相当于我们的转移方程f[i][j]=max(f[i−1][j],f[i−1][j−w[i]])，因为现在的f[j−w[i]]就相当于原来的f[i−1][j−w[i]]。如果将V的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][j]由f[i][j−w[i]]推知，与本题意不符，但它却是另一个重要的背包问题（完全背包）最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。<br>
事实上，使用一维数组解01背包的程序在后面会被多次用到，以后的代码中就直接调用不再加以说明。<br>
<img src="https://520cxy.github.io/post-images/1625282638813.png" alt="" loading="lazy"><br>
注意这个过程里的处理与前面给出的代码有所不同。前面的示例程序写成j=V...0是为了在程序中体现每个状态都按照方程求解了，避免不必要的思维复杂度。而这里既然已经抽象成看作黑箱的过程了，就可以加入优化。费用为w[i]的物品不会影响状态f[0...j−1]，这是显然的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[狗崽腿]]></title>
        <id>https://520cxy.github.io/post/gou-zai-tui/</id>
        <link href="https://520cxy.github.io/post/gou-zai-tui/">
        </link>
        <updated>2021-06-29T01:56:19.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7115">[NOIP2020] 移球游戏</a><br>
<font color = purple><strong>省选/NOI-</strong></font><br>
<strong>好像就是大大大大大模拟</strong>， 利用栈的特性，对每列每种颜色构造出“全色列”，对于每次构造，我们采用一个空栈和一个满栈，我们枚举每次移动的颜色，记每列该颜色的数量为t<sub>1</sub>，那么每次先移动空栈前一个t<sub>1</sub>个球到空栈里，然后将当前栈里的当前颜色的移动到空栈前一个栈上，将其他颜色的球移动到空栈上；之后再把空栈上的n-t<sub>1</sub>个球放到当前栈上，之后我们我们看当前列的下一列，把这列当做当前列，再把当前列的其他颜色放到上一列上，然后当前颜色放到空列上，我们记这样的操作为一次操作。最后只要枚举颜色，在每个颜色进行枚举栈并循环操作就能分离所有颜色了。</p>
<p><a href="https://codeforces.com/problemset/problem/618/F">Double Knapsack</a><br>
<font color = black><strong>NOI/NOI+/CTSC</strong></font><br>
显然先对每个集合内元素升序排序，做前缀和而要使他们的元素和相等，我们想到的肯定是选择每个集合内的某两个区间，<s>正确性显然</s>我们设<strong>c<sub>i</sub>表示最大的j使得s<sub>ai</sub>&gt;=s<sub>bj</sub></strong> 整理得：s<sub>ai</sub>-s<sub>b<sub>ci</sub></sub> &lt; b<sub>ci+1</sub><br>
所以题目的差共有n+1种可能。再根据狗朝园里可知至少有两个差值是相等的之后就枚举就行了<br>
哇，k掉了黑题！</p>
<p><a href="https://atcoder.jp/contests/arc103/tasks/arc103_d">Distance Sums</a><br>
<font color = purple><strong>省选/NOI-</strong></font><br>
这题有个奇怪的结论，就是由于你的d是一定的，然后距离根最大的点肯定是叶子，而且这题中，根不是重心也在重心周围，我们对于每个距离就选择从叶子结点往上做，最后判断这是不是一棵树就行；</p>
<p><a href="https://codeforces.com/problemset/problem/1495/C">CF1495C Garden of the Sun</a><br>
<font color = blue><strong>提高+/省选-</strong></font><br>
结论：每两行进行操作，先把第一列全染了，然后某两排X中间的某一排的第二列有X就会出锅，所以这种情况就把第二列全染成X</p>
<p><a href="https://codeforces.com/problemset/problem/1408/F">CF1408F Two Different</a><br>
<font color = blue><strong>提高+/省选-</strong></font><br>
结论：当n为2次幂时，我们可以直接n log n 次选择两两染色，不为2次幂时，我们把n分为1 ~ 2<sup>k</sup>，和n-2<sup>k</sup>+1 ~ n，两个区间进行操作，显然前面就按照结论操作，后面的那个区间，如果前面是一种颜色，后面是另一种颜色就做完了，k为最大2<sup>k</sup> &lt;= n</p>
<p><a href="https://codeforces.com/problemset/problem/1333/E">CF1333E Road to 1600</a><br>
<font color = purple><strong>省选/NOI-</strong></font><br>
首先手推出一个3*3内，车一定比后优的矩阵</p>
<blockquote>
<p>{1， 5， 8<br>
3， 6， 4<br>
2， 9， 7}</p>
</blockquote>
<p>然后其他格子就填充后与车同级的路线，因为最后必定会进入这个3*3的矩阵内，这时后就被卡掉了，就保证了车的优秀</p>
<p><a href="https://codeforces.com/problemset/problem/804/E">CF804E The same permutation</a><br>
<font color = black><strong>NOI/NOI+/CTSC</strong></font><br>
对于一个n， 如果%4=2||3就无解当n被4整除时，发现这些数4个一块，按照(1,2) (3,4) (1,4) (2,3) (1,3)(2,4) 交换刚好能把块内循环一次,而块与块之间的循环，我们设(x, y)表示第一块的x与第二块的y交换</p>
<blockquote>
<p>• (1,1) (2,2) (1,2) (2,1)<br>
• (1,3) (2,4) (1,4) (2,3)<br>
• (3,1) (4,2) (3,2) (4,1)<br>
• (3,3) (4,4) (3,4) (4,3)</p>
</blockquote>
<p><a href="https://codeforces.com/problemset/problem/858/F">CF858F Wizard's Tour</a><br>
<font color = purple><strong>省选/NOI-</strong></font><br>
这题先考虑树的解法，对于每一个点，过程大致是这样的：先解决儿子的问题 -&gt;再解决当前点的问题-&gt; 把不能解决的问题留给父亲。<br>
上述的解决问题就是指两条相邻边的匹配，可以发现，只有根节点一条边可能会匹配不到，其他的要么自己要么父亲都处理掉了，这种算法的正确性就很显然了，因为它构造出的答案已经达到了可能的答案上界。<br>
拓展到图的情况，我们对每一个联通块都考虑它的生成树，我们把返祖边当作连向儿子的边处理即可，正确性可以用树的方法说明。<br>
在具体实现中，我们把每一个点上未匹配的边存到p数组中，然后我们在访问儿子时需要把这条边删去，用网络流类似的方法。<strong>边数一开始记得赋1</strong></p>
<p><a href="https://codeforces.com/problemset/problem/1450/C2">CF1450C2 Errich-Tac-Toe (Hard Version)</a><br>
<font color = blue><strong>提高+/省选-</strong></font><br>
结论：如果我们能让连续的三个棋子中至少出现一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 和一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>，那么就能避免三个连续相同棋子的情况，形成平局<br>
（相当于我们需要选择间隔相同的 X XX 对角线与 O OO 对角线对棋盘进行分割，避免出现三个棋子同色的情况）<br>
同一排或者同一列三个连续的棋子满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo>)</mo><mi mathvariant="normal">%</mi><mn>3</mn><mo>=</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">(i + j) \% 3 == 0, 1, 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mord">%</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span></span>因此我们可以按照 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">( i + j ) % 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 来对所有的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span> 进行统计，假设数量为X<sub>0</sub>,X<sub>1</sub>,X<sub>2</sub>,O<sub>0</sub>,O<sub>1</sub>,O<sub>2</sub><br>
显然k=X<sub>0</sub>+X<sub>1</sub>+X<sub>2</sub>+O<sub>0</sub>+O<sub>1</sub>+O<sub>2</sub>,需要使得连续的三个棋子中出现一个X或O，那么我们需要在X<sub>0</sub>,X<sub>1</sub>,X<sub>2</sub>中选择一个并在O<sub>0</sub>,O<sub>1</sub>,O<sub>2</sub>中选择一个位置不同的进行修改，找到最小的X<sub>i</sub>+O<sub>j</sub>,满足X<sub>i</sub>+O<sub>j</sub>&lt;=⌊ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>k</mi><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{k}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>⌋,最后根据选择的两个数字对棋盘棋子进行翻转输出就行</p>
<p><a href="http://codeforces.com/problemset/problem/1494/D">Codeforces 1494D Dogeforces</a><br>
<font color = blue><strong>提高+/省选-</strong></font><br>
因为上级严格比下级大，把a[i][j]从小到大排序，然后就能从下往上构造了,并查集模拟一下<br>
注意排序的同时，还要把i,j排序，也就是一堆相同的值中，先把i的全部给构造完了，这样就不会出现冲突了<br>
我还是举个栗子<br>
比如1 2 3 4都是父亲是5，但是你在排序的时候搞出了1 2父亲是5，然后处理3 4，发现他们的父节点都是他们自己，所以搞出个新节点父亲6，最后发现1,3的父亲还是权值和5,6一样，就会出问题，相当于多创建了一个点，但如果一开始排序就先 1 2 ,1 3,1 4,就会只有一个父亲5</p>
<p><a href="http://codeforces.com/problemset/problem/1004/D">CF1004D Sonya and Matrix</a><br>
<font color = purple><strong>省选/NOI-</strong></font><br>
发现，当我们确定了0的横坐标时，其纵坐标也可以确定了，设 0的坐标为（x，y），矩阵的大小为（m，n），矩阵第一行第一列为（1，1）(在这里我们要把矩阵翻过来看）；设 a=x-1+y-1 , b=m-x +n-y;<br>
则a表示0到（1，1）的距离，b表示0到m，n的距离，这里注意，很容易知道b的值就是输入数中最大的那一个，因为最大的那个数距离0是最远的。<br>
将a=x-1+y-1 , b=m-x +n-y合并得 a=m+n-2-b;代入a=x-1+y-1中得到y=n+m-b-x; 如果 a[i] != 4*i,x=i;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[summer？]]></title>
        <id>https://520cxy.github.io/post/shu-jia/</id>
        <link href="https://520cxy.github.io/post/shu-jia/">
        </link>
        <updated>2021-06-29T00:23:17.000Z</updated>
        <content type="html"><![CDATA[<p><font size=6><strong>6.29:</strong></font><br>
<a href="https://www.luogu.com.cn/problem/P2363">马农</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
标签给定的是dp，其实就是暴力枚举， 对于限定条件<font color=red>矩阵权值一样，且只有一个交点。</font>就可以直接枚举矩阵权值与交点；<br>
先做二维矩阵和，再N<sup>2</sup>枚举交点，之后分情况枚举矩阵的权值和，开个数组存不同和的方案数，然后ans加过去就过了，而对于枚举的两个矩阵只有一个左上，一个右下；一个右上，一个左下这两种。<br>
<img src="https://520cxy.github.io/post-images/1624926912914.png" alt="" loading="lazy"></p>
<p><a href="https://www.luogu.com.cn/problem/P4655">[CEOI2017]Building Bridges</a><br>
<font color=purple><strong>省选/NOI-</strong></font><br>
显然，对于第i个柱子，我们连接的代价为建桥代价+拆除代价：W<sub>总</sub> = (h<sub>i</sub>-h<sub>j</sub>)<sup>2</sup>+(s<sub>i-1</sub>-s<sub>j</sub>)， (j为上一个柱子端点)化简后得：W<sub>总</sub>=h<sub>i</sub><sup>2</sup>+h<sub>j</sub><sup>2</sup>-2h<sub>i</sub>h<sub>j</sub>+s<sub>i-1</sub>-s<sub>j</sub>，而影响对于i总代价的变量只有j，设a<sub>j</sub> = -2h<sub>j</sub>, b<sub>j</sub>=h<sub>j</sub>+f<sub>j</sub><sup>2</sup>-s<sub>j</sub>;<br>
f<sub>i</sub> = h<sub>i</sub><sup>2</sup>+s<sub>i-1</sub>+min{a<sub>j</sub>h<sub>i</sub>+b<sub>j</sub>}<br>
问题就转化为<font color=red>给定直线y<sub>j</sub>=a<sub>j</sub>x+b<sub>j</sub>,求当x=h<sub>i</sub>时，y<sub>j</sub>的最小值</font><br>
而对于这样动态插入直线，维护最优解，我跟wcr学到了<strong>李超线段树</strong></p>
<p><font size=6 color=red><strong>7.1 :</strong></font><br>
<font color=red size=6><strong>！！！庆祝中国共产党建立100周年！！！</strong></font><br>
<a href="https://www.luogu.com.cn/problem/P1773">符文之语</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
f[i][j]表示用前i个字符，满足最小乘积（对m取余后的）所需要划分的阶段（要加的括号），<br>
对于每个i可以取到的j，由f[j][k]推出当前位，之后取最优解<br>
<img src="https://520cxy.github.io/post-images/1625122781301.png" alt="" loading="lazy"></p>
<p><a href="https://www.luogu.com.cn/problem/P2330"> [SCOI2005]繁忙的都市</a><br>
<font color = yellow><strong>普及/提高-</strong></font><br>
最小生成树kruskal的板子题，最少边数肯定是n-1，最小值的最大值取max就行</p>
<p><a href="https://www.luogu.com.cn/problem/P1339">[USACO09OCT]Heat Wave G</a><br>
<font color = yellow><strong>普及/提高-</strong></font><br>
迪杰斯特拉加个堆优化就过了，注意题目是<strong>无向图</strong>所以<font size=5><strong>要建双向边！！！</strong></font>,我忘了，交了好几遍才发现😭😭😭</p>
<p><a href="https://www.luogu.com.cn/problem/P1111">修复公路</a><br>
<font color = yellow><strong>普及/提高-</strong></font><br>
贪心从时间小的开始修，每修一条路，用并查集判断两个村是不是已经联通了，如果没有就合并，连接的村庄数量cnt++，当cnt==n-1就直接输出当前这条路的时间return 0，否则接着修，如果路修完就结束循环，puts(&quot;-1&quot;);</p>
<p><font size=6>7.2:</font><br>
<a href="https://www.luogu.com.cn/problem/P1991">无线通讯网</a><br>
<font color=green><strong>普及+/提高</strong></font><br>
感觉写题面的人语文跟没学过一样，非要整这些花里胡哨的，看都看不懂，说白了就是在坐标系上给你p个点，然后要求全联通的距离最小，给了s就相当于你可以连接任意s/2对点并且代价为0，直接上克鲁斯卡尔，然后要让代价最小，我们肯定把距离最大的变为0，所以相当于最大的那s个点不用连了，只要边数==p-s就做完了，然后ans一直更新边权就行，还有就是建边的时候，每个点和其他的p-1个点都要建</p>
<p><a href="https://www.luogu.com.cn/problem/P1346">电车</a><br>
<font color = yellow><strong>普及/提高-</strong></font><br>
题目中<strong>如果电车司机想走另一个轨道，他就必须下车切换开关的状态</strong>问最少下车几次，问题就转化为：对于任意一个路口，他可以花费0的代价到默认的路口，花费1的代价到其他路口，然后建图跑最短路就行</p>
<p><a href="https://www.luogu.com.cn/problem/P2661">[NOIP2015 提高组] 信息传递</a><br>
<font color = yellow><strong>普及/提高-</strong></font><br>
题目中，游戏的结束定义为<strong>有人从别人口中得知自己的生日</strong>如果我们把一个信息看成一个节点，每个人为一棵树，每次传递信息就是合并两棵树，那么结束条件相当于<strong>有人的子节点为自己</strong>就是一个<strong>环</strong>的情况，可以进行的轮数就是<strong>图中最小环的长度</strong>，这道题只需要每次加一个点就建边，边加边做，然后如果i和t<sub>i</sub>的祖先不同，就更新深度与父节点，否则取min更新答案，最后输出最小长度就行</p>
<p><a href="https://www.luogu.com.cn/problem/P1283">平板涂色</a><br>
<font color=blue><strong>提高+/省选-</strong></font><br>
一道状压题，我们设f[i][j] = x,表示状态为x时，最后一次刷j色用的最少次数，s 的二进制的从右往左数的第 i 位（1/0）代表了（是/否）涂了第i块， 如果颜色相同就直接刷，否则次数加一<br>
<img src="https://520cxy.github.io/post-images/1625197325448.png" alt="" loading="lazy"><br>
还有就是刷的时候需要判断限界条件<strong>一个矩形只能在所有紧靠它上方的矩形涂色后，才能涂色</strong>所以在转移状态的时候要check一下<img src="https://520cxy.github.io/post-images/1625197483250.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我们毕业了]]></title>
        <id>https://520cxy.github.io/post/wo-men-bi-ye-liao/</id>
        <link href="https://520cxy.github.io/post/wo-men-bi-ye-liao/">
        </link>
        <updated>2021-06-25T05:13:01.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://520cxy.github.io/post-images/1624621129736.gif" alt="" loading="lazy"><br>
<font face = "楷体"> <center><br>
<font color = orange><font size=5>一张新拍的照片<br>
好像带给我一点点怀念<br>
食堂周围的那一片<br>
味道弥漫过铺满树叶的小院<br>
阳光透过树叶好像一丝一线<br>
夕阳照了一遍我眯着眼<br>
那张同桌寄的明信片<br>
安静的躺在课桌的里面<br>
快要过完的春天<br>
还有深绿破烂的窗帘<br>
窄窄的长长的过道两边<br>
双子大厦依然在抽着烟<br>
刚刚下完了小雨的季节<br>
体育课不知调到第几节<br>
记不得哪年的哪一天<br>
很漫长又很短暂的岁月<br>
现在已经回不去<br>
早已流逝的光阴<br>
校牌里的那一张渐渐模糊不清的丑照<br>
成了回忆的信号<br>
忘不掉的是什么我也不知道<br>
想不起当年模样<br>
看也看不到 去也去不了的地方<br>
也许那课间的嬉笑是属于我们的忧伤<br>
嘴角那点微笑越来越勉强<br>
忘不掉的是什么我也不知道<br>
放不下熟悉片段<br>
回头望一眼 仿佛很多年的时间<br>
透过手指间看着天<br>
我又回到那教室一间间<br>
靠在你们身边渐行渐远</font></font></center></font><br>
<font face = "楷体">                       致敬----------------18.9.1~21.6.25</font></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SOL_加工生产调度]]></title>
        <id>https://520cxy.github.io/post/sol_-jia-gong-sheng-chan-diao-du/</id>
        <link href="https://520cxy.github.io/post/sol_-jia-gong-sheng-chan-diao-du/">
        </link>
        <updated>2021-06-15T07:23:34.000Z</updated>
        <content type="html"><![CDATA[<p><font size=2 color=green><s>突然想起来我还有博客</s>大雾</font><br>
<a href="https://www.luogu.com.cn/problem/P1248">题面传送门</a><br>
<font size=6 color=blue>1.问题分析</font><br>
根据题面的描述，不同的加工顺序，加工完机器所需零件不同<br>
例如：现在有3个机器零件{J<sub>1</sub>, J<sub>2</sub>, J<sub>3</sub>}, 在第一台机器上加工时间分别为2、5、4，在第二台机器上加工时间分别为3、1、6<br>
<font color=brown size=4>(1)如果按照{J<sub>1</sub>, J<sub>2</sub>, J<sub>3</sub>}的顺序加工</font><br>
如下图所示：<br>
<img src="https://520cxy.github.io/post-images/1623743000390.png" alt="" loading="lazy"><br>
J<sub>11</sub>、J<sub>21</sub>、J<sub>31</sub>分别表示第1、2、3个零件在第一台机器上的加工时间。J<sub>12</sub>、J<sub>22</sub>、J<sub>32</sub>分别表示第1、2、3个零件在第二台机器上的加工时间。<br>
第一台机器先加工第1个零件，需要加工的时间为J<sub>11</sub>=2,t=2时结束，交给第二台机器加工，此时第二台机器储蓄空闲状态，需要加工时间为J<sub>12</sub>=3,t=5时结束，这时第二台机器处于空闲状态，等待第2个零件在第一台机器上下线<br>
第一台机器接着加工第2个零件，需要J<sub>21</sub>=5, t=7时结束，交给第二台机器加工，此时第二台机器处于空闲状态，需要加工时间为J<sub>22</sub>=1,t=8时结束，这时第二台机器处于空闲状态，等待第3个零件在第一台机器上下线<br>
第一台机器接着加工第3个零件，需要J<sub>31</sub>=4,t=11时结束，交给第二台机器加工，此时第二台机器处于空闲状态，需要加工时间为J<sub>32</sub>=6,t=17时结束<br>
<font color=red>我们得到t<sub>1</sub>=17</font><br>
<font color=brown size=4>(2)如果按照{J<sub>1</sub>, J<sub>3</sub>, J<sub>2</sub>}的顺序加工</font><br>
如下图所示：<br>
<img src="https://520cxy.github.io/post-images/1623744295684.png" alt="" loading="lazy"><br>
第一台机器先加工第1个零件，需要加工时间为J<sub>11</sub>=2,t=2时结束，交给第二台机器加工，此时第二台机器处于空闲状态，需要加工时间为J<sub>12</sub>=3,t=5时结束，此时第二台机器处于空闲状态，等待第3个零件在第一台机器上下线<br>
第一台机器接着加工第3个零件，需要J<sub>31</sub>=4,t=6时结束，交给第二台机器加工，此时第二台机器处于空闲状态，需要加工时间为J<sub>32</sub>=6,t=12时结束<br>
第一台机器接着加工第2个零件需要J<sub>21</sub>=5,t=11时结束，交给第二台机器加工，此时第二台机器处于繁忙状态，需要等待其空闲下来，t=12时才能加工，加工时间为J<sub>22</sub>=1,t=13时结束<br>
<font color=red>我们得到t<sub>2</sub>=13</font>,显然比第一种更优</p>
<p>我们可以得出一个有趣的现象：第一台机器可以连续加工，而第二台机器开始加工的时间是<font color=red><strong>当前第一台机器的下线时间和第二台机器下线时间的最大值</strong></font>就是图中连线的两个数值的最大值</p>
<p>3个机器零件有多少种加工顺序呢？即3个机器零件的全排列，共6种：<br>
1 2 3； 1 3 2； 2 1 3； 2 3 1； 3 2 1； 3 1 2；<br>
而我们的目的就是找到其中一个加工顺序，使得总加工时间最短<br>
实际上就是找到n个机器零件的一个排列，n个机器零件共有n！种排列，每个排列都是一种可行解。解空间是一棵排列树，如下图<br>
<img src="https://520cxy.github.io/post-images/1623748899996.png" alt="" loading="lazy"><br>
例如3个机器零件的解空间树，如下图<br>
<img src="https://520cxy.github.io/post-images/1623749495559.png" alt="" loading="lazy"><br>
从根到叶子的路径就是机器加工的一个加工顺序，如最右侧的（3，1，2），然后定义限界函数求最优解</p>
<p><font size=6 color=blue>2.算法设计</font><br>
<font color=brown size=4>(1)定义问题的解空间</font><br>
机器零件加工问题解的形式为n元组：{x<sub>1</sub>, x<sub>2</sub>,..., x<sub>i</sub>,..., x<sub>n</sub>}。分量x表示第i个加工的零件号n个零件做成的集合为S={1， 2， …， n}, x<sub>i</sub>的取值为S-{x<sub>1</sub>, x<sub>2</sub>,..., x<sub>i-1</sub>}， i=1, 2, ..., n<br>
<font color=brown size=4>(2)解空间的组织结构</font><br>
就是一棵排列树，如图<br>
<img src="https://520cxy.github.io/post-images/1623750346102.png" alt="" loading="lazy"><br>
<font color=brown size=4>(3)搜索解空间</font><br>
● <font color=black>约束条件</font><br>
由于任何一种零件加工次序不存在无法调度的情况，均是合法的。因此，任何一个排列都表示为问题的一个可行解，故不需要约束条件<br>
● <font color=black>限界条件</font><br>
用f<sub>2</sub>表示当前已完成的零件在第二台机器加工所用的时间，用bestf表示当前找到的最优加工方案的完成时间。显然，继续向深处搜索时，f<sub>2</sub>不会减少，只会增加。因此当f<sub>2</sub>⩾bestf时，就没有继续向深处搜索的必要。限界条件可以描述为：f<sub>2</sub>&lt;bestf, f<sub>2</sub>的初值为0，bestf的初值为无穷大。<br>
● <font color=black>搜索过程</font><br>
扩展结点沿着某个分支扩展时需要判断限界条件，如果满足，就进入深一层继续搜索；如果不满足，就剪掉该分支。搜索到叶子结点时，就找到当前最优解。搜索直到全部的活结点变成死节点为止。</p>
<p><font size=6 color=blue>3.完美图解</font><br>
例子跟一开始的一个鸭子，现在有3个机器零件{J<sub>1</sub>, J<sub>2</sub>, J<sub>3</sub>}, 在第一台机器上加工时间分别为2、5、4，在第二台机器上加工时间分别为3、1、6。f<sub>1</sub>表示当前第一台机器上加工的完成时间，f<sub>2</sub>表示当前第二台机器上加工的完成时间。<br>
<font size=4 color=brown>（1）开始搜索第一层(t=1)</font><br>
扩展A结点的分支x<sub>1</sub>=1,f<sub>2</sub>=5,bestf的初值为无穷大，f<sub>2</sub>&lt; bestf，满足限界条件，令x[1]=1，生成B结点<br>
<img src="https://520cxy.github.io/post-images/1623803034925.png" alt="" loading="lazy"><br>
<font size=4 color=brown>（2）扩展B结点(t=2)</font><br>
扩展B结点的分支x<sub>2</sub>=2, f<sub>2</sub>=8,bestf初值为无穷大，满足限界条件，令x[2]=2，生成C结点<br>
<img src="https://520cxy.github.io/post-images/1623804450415.png" alt="" loading="lazy"><br>
<font size=4 color=brown>（3）扩展C结点(t=3)</font></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP分析]]></title>
        <id>https://520cxy.github.io/post/dp-fen-xi/</id>
        <link href="https://520cxy.github.io/post/dp-fen-xi/">
        </link>
        <updated>2021-04-19T05:43:59.000Z</updated>
        <content type="html"><![CDATA[<p><font size=6 color=red>1.为什么做dp要分析：</font><br>
比如，我们在计算123x456时，会使用竖式计算<s>你牛你口算</s>，<br>
<img src="https://520cxy.github.io/post-images/1618811515575.png" alt="" loading="lazy"><br>
但是要是我们口算234x567，对于我这种蒟蒻肯定是很困难的。<br>
那么做dp题目的时候也一样，很多时候我们做dp题目喜欢干瞪眼看， 确信。然后就空想，不动笔不动纸，那么这样情况下就白白给自己增加了很多难度。<font color=green>那么dp分析法，就是相当于乘法列竖式一样的一个使解决问题思路清晰的方式</font></p>
<p><font size=6 color=red>2.核心</font><br>
<font color=red>核心就是从集合的角度来分析dp问题</font><br>
回想我们之前做过的dp问题， 我们发现都是<font color=red>有限集内最优化、最值问题</font><br>
由于大多问题集内元素个数都为指数级，所以枚举运算起来的时间复杂度很高，因此我们要用dp优化</p>
<p><font color=red size=6>3.为什么dp可以优化这些问题</font><br>
<font color=green>dp过程中，要经历两个阶段</font><br>
<font color=blue size=5>阶段一：化零为整，即状态表示</font><br>
我们每次在处理问题时，不是一个方案一个方案，一个元素一个元素枚举，而是每次枚举一堆元素、枚举一个子集、枚举一类东西， 就是<font color=red>把一些有着相似性质的东西化为一个子集，用某个状态来表示， 就是化零为整的过程</font>。</p>
<p><font color=green>状态表示里我们一般要从两个角度分析</font>，，<br>
<font size=4 color=purple>第一个角度：</font><br>
我们的状态，比如f[i]，要考虑f[i]表示的是哪个集合，就是集合是什么。那么这个集合一般表述的方式就是：<font color=red>所有满足XXX条件的方案的集合。</font>正因为f[i]表示的是一类东西，所以枚举f[i]可以优化</p>
<p><font size=4 color=purple>第二个角度：</font><br>
第二个要考虑的就是f[i]虽然表示的是一个集合，但是存入数组的是一个数字或bool值。那么<font color=red>这个数和这个集合的关系，我们称为属性</font>，说白了就是我们这个集合存的是什么东西，<font color="#00dddd">属性一般有三种：maxn，minn，count</font></p>
<p><font color=blue size=5>阶段二：化整为零， 即状态计算</font><br>
与阶段一相反，这个等等举例。那么怎么去做？<font color=red>先看f[i]表示的所有状态是什么，然后把整个状态里看成一个集合，那么求f[i]就需要把整个集合划分为若干个子集。</font><br>
<img src="https://520cxy.github.io/post-images/1618814570057.png" alt="" loading="lazy"><br>
这些子集一般又符合两个原则；<br>
<font color=pink>原则一，不重复：</font>就是每个元素是单独属于其中一个子集；<br>
<font color=pink>原则二，不遗漏：</font>就是所有子集并集的元素一定把f[i]集合中所有元素都包含了。<br>
这时我们要求f[i]就是要求每个子集的值。<font color="#00dddd">比如我们现在f[i]的属性是最大值，那么整个集合最大值是什么，就是我们每个子集的最大值再取一个最大值；如果f[i]的属性是数量，那么整个集合的数量就是所有子集的数量之和。</font><br>
所以我们把<font color=red>整个集合的问题划分为若干个子集的小问题，我们去处理每个子集，再把每个子集计算后的结果整理得出f[i]的值，就是一个化整为零的过程</font>；<br>
有个要注意的地方，就是上面子集划分的两个原则，并不是一定所以情况下都要满足，首先不遗漏很清楚，要满足的，<font color=red>但是不重复需要注意：当我们求数量的时候，我们必须要满足不重复。但是当我们求最值的时候，其实可以重复，这点利用传递性很好理解，就是计算多了。</font></p>
<p>然后集合划分，我们一般也有个套路，我们一般是怎么去划分这个集合呢？<br>
<font color=red>划分依据：找最后一个不同点。</font></p>
<p>在找递推式子的时候，我们一般先假设我们已经求出了答案，顺藤摸瓜，就能更好地划分每个状态</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原根代码及优化]]></title>
        <id>https://520cxy.github.io/post/yuan-gen-dai-ma-ji-you-hua/</id>
        <link href="https://520cxy.github.io/post/yuan-gen-dai-ma-ji-you-hua/">
        </link>
        <updated>2021-04-13T10:59:10.000Z</updated>
        <content type="html"><![CDATA[<p><font color=green size=5><strong>CODE</strong></font><br>
<img src="https://520cxy.github.io/post-images/1619069324790.png" alt="" loading="lazy"><br>
<img src="https://520cxy.github.io/post-images/1619069332113.png" alt="" loading="lazy"><br>
这是最常用的方法<br>
如果你还想要更优的复杂度：<br>
删去<br>
<img src="https://520cxy.github.io/post-images/1619069374435.png" alt="" loading="lazy"><br>
加上<br>
<img src="https://520cxy.github.io/post-images/1619069410903.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="1"><img src="https://520cxy.github.io/post-images/1619069561433.png" alt="" loading="lazy"></figure>
<p>还有更快的！！！<br>
现在发现瓶颈在枚举的数量上，其实还可以优化<br>
有一个结论：设φ ( m ) = p<sub>1</sub><sup>a<sub>1</sub></sup> * p<sub>2</sub><sup>a<sub>2</sub></sup> * ... * p<sub>n</sub><sup>a<sub>n</sub></sup><br>
那么只需要判断：<img src="https://520cxy.github.io/post-images/1618471759699.png" alt="" loading="lazy"><br>
如果有一个条件满足，那么当前的g一定不是原根如果对于一个φ(m)的因数b满足了条件，那么在这些数当中一定至少有一个也满足这个条件，然后就好啦<br>
代码依然用替换来给出，替换上文提到的地方<br>
<img src="https://520cxy.github.io/post-images/1619069458700.png" alt="" loading="lazy"><br>
<img src="https://520cxy.github.io/post-images/1619069496529.png" alt="" loading="lazy"><br>
完结撒花</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4.5 Solution]]></title>
        <id>https://520cxy.github.io/post/45-solution/</id>
        <link href="https://520cxy.github.io/post/45-solution/">
        </link>
        <updated>2021-04-05T06:46:08.000Z</updated>
        <content type="html"><![CDATA[<p><font size=6>T1:纯粹理性批判</font><br>
<font size=4>题目描述：</font><br>
<img src="https://520cxy.github.io/post-images/1617605412575.png" alt="" loading="lazy"><br>
样例输入：10<br>
样例输出：21<br>
<font size=4>方法：</font><br>
我们将所有a, b的情况分为三类 ：<br>
<font color=green>1. a = b 时</font>， 显然不可能(自己举栗子)<br>
<font color=green>2. a &gt; b 时</font>， 此时<font color=blue>b/a = 0</font> 要满足a%b = 0， 则<font color=red>所求二元组为b是a的因子</font><br>
<font color=green>3. a &lt; b 时</font>，此时<font color=blue>a%b = a</font> 要满足b/a=a， 则<font color=red>所求二元组数为区间数量a<sup>2</sup> &lt; b &lt; a<sup>2</sup>+a</font><br>
然后统计答案</p>
<p><font size=6>T2:自我救赎</font><br>
<font size=4>题目描述：</font><br>
<img src="https://520cxy.github.io/post-images/1617607036161.png" alt="" loading="lazy"><br>
样例输入:<br>
5<br>
5 4 3 2 1<br>
样例输出:<br>
4<br>
<font size=4>方法：</font></p>
<blockquote>
<p>数据太水O(n<sup>2</sup>)暴力枚举，只要往后扫，一碰到比它大的就++，break，直接过</p>
</blockquote>
<p><font size=6>T4:失乐园</font><br>
<font size=4>题目描述：</font><br>
<img src="https://520cxy.github.io/post-images/1617607354812.png" alt="" loading="lazy"><br>
样例输入：<br>
8<br>
20152016<br>
样例输出：<br>
4<br>
样例解释：<br>
”20152016” = ”20152016”<br>
”20152016” = ”20” + ”152016”<br>
”20152016” = ”201” + ”52016”<br>
”20152016” = ”2015” + ”2016”</p>
<p><font size=4>方法：</font><br>
<font color=red>区间DP</font>，<br>
但是要先做一个LCP（最长公共前缀）优化<s>我不会</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4.2 Solution]]></title>
        <id>https://520cxy.github.io/post/42-solution/</id>
        <link href="https://520cxy.github.io/post/42-solution/">
        </link>
        <updated>2021-04-02T02:04:33.000Z</updated>
        <content type="html"><![CDATA[<p><font size=5>T1 生成字符串</font><br>
在模拟的时候发现，如果他给出了<font color=red>连续的n个T<sub>1</sub>操作，就是翻转n%2次</font>，而串首串尾加字符，如果加了以后翻转，就等价于反着加，我们只需要记下每次操作填补的位置最后进行操作就行；</p>
<p><font size=5>T2 字符串查询</font><br>
据dalao们说是线段树和树状数组的维护，<s>我也看出来了</s>，但是我没<s>马</s>码；</p>
<p><font size=5>T3 下取整</font><br>
只要按照题目描述的进行操作之后，存下来的数和原数比较，反正我是做了一遍<font color=red>数学的逆运算</font>就切了唔</p>
<p><font size=5>T4 整除</font><br>
原题：<a href="https://atcoder.jp/contests/abc158/tasks/abc158_e">ABC158 E - Divisible Substring</a><br>
思维题，有一个很特别的性质吧，我也不知道叫什么，<font color=red>比如你的s[i]%p=k, s[j]%p=k,那么，<img src="https://520cxy.github.io/post-images/1617330955337.png" alt="" loading="lazy"></font><br>
<font color=green>所以在区间[i, j]中的数都能取，之后统计i~j中所有区间长度的区间个数累计加起来</font><br>
还有就是要注意p=2, 5的情况需要特判，由于这俩很好判断，<font color=red>只要末尾上的数可以整除那么前面一系列数都能取</font></p>
<p><font size=5>T5 机器人</font><br>
原题：<a href="https://atcoder.jp/contests/abc158/tasks/abc158_f">ABC158 F - Removing Robots</a><br>
首先这是一个DAG模型，一个机器的激活可以引起另一个的激活，这样我们根据某一机器人向能够引起爆炸的另外一个机器人连边便可以得到一张<font color=red>有向无环图</font><br>
事实上，有向无环图我们很难建立而且很难在上面完成答案的计算；<br>
因此题解中有一个很妙的思路：</p>
<blockquote>
<p>将DAG中多余的边去掉，使其变成一个树结构<br>
我们将<strong>多于的边去掉首先需要保证的是不会影响答案的计算</strong></p>
</blockquote>
<p>例如(A,B),(B,C),(A,C)这三条边中我们完全可以将(A,C)去掉，因为这两条路径是等价的。<br>
因此我们对于每一节点，只需要<font color=red>向离节点最左边位置的节点连边</font>即可。<br>
在程序实现上，我们可以使用优先队列/栈来维护：<br>
我们反向考虑，对于没有受到连边的节点放到一个容器使得容器的顶部位置最小。<br>
（为了能更容易的得到连边）<br>
若当前可以向容器的顶部连边，则连边并弹出顶部，直到不能连边为止。<br>
<font color=green>最优我们得到了一个森林结构，我们以每一个根为起点做树形DP。<br>
DP很很好写——xhf dalao</font><br>
我们设f[i]表示以i为根子树的选择方案。<br>
当i启动时，子树都需要启动，方案为1。<br>
当i不启动时，方案为子树的f值得积<br>
最后的答案是森林中每一个根的f值之积。<br>
<img src="https://520cxy.github.io/post-images/1617330304397.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Re:树链剖分的起源之战]]></title>
        <id>https://520cxy.github.io/post/reshu-lian-pou-fen-de-qi-yuan-zhi-zhan/</id>
        <link href="https://520cxy.github.io/post/reshu-lian-pou-fen-de-qi-yuan-zhi-zhan/">
        </link>
        <updated>2021-03-31T12:26:49.000Z</updated>
        <content type="html"><![CDATA[<p><font size=6><strong>哲学</strong>三问</font><br>
<font size=4 >一.树链剖分是啥？</font><br>
<font color=red>树链，就是树上的路径。剖分，就是把路径分类为重链和轻链。</font><br>
<font size=4 >二.树链剖分用来干啥？</font></p>
<blockquote>
<p>有的人说：“我会树上倍增，我怕谁？”，没错，你怕的就是树链剖分。<br>
意思是：树上倍增能做的，树链剖分都能做；树链剖分能做的，树上倍增不一定能做<s>就像那啥，树状数组能做的线段树一定能做，线段树能做的，树状数组不一定能做</s>。树上倍增虽然能求树上区间极值或和，但一旦有树上边或点权值修改的操作，您就爆dan了这时我们需要一个新的算法来补上我们的树上倍增操作的漏洞，没错，就是<strong>树链剖分</strong>！没错！你学了它<s>一定</s>不会后悔！!</p>
</blockquote>
<p><a href="https://edge-bird.github.io/2021/01/30/Binary%20Index%20Tree/">树状数组</a> &lt;--- 不会点这里，<s>营销大鸟</s>的blog<br>
<font color=red>在一棵树上进行路径的修改、求极值、求和”</font>乍一看只要线段树就能轻松解决，实际上，仅凭线段树是不能搞定它的。我们需要用到一种<s>貌似</s>高级的复杂算法—<strong>树链剖分</strong></p>
<p><font size=4 >三.树链剖分咋用？</font><br>
如果要使用树链剖分，概念滴你们滴需要懂滴</p>
<blockquote>
<p>对于一个节点，在它的所有儿子中，size（子树大小）最大的一个就是<strong>重儿子</strong>，其余的都是<strong>轻儿子</strong>。重儿子所在的树链叫做<strong>重链</strong>，其余叫做<strong>轻链</strong>。</p>
</blockquote>
<p><font color=blue>e.g:</font><img src="https://520cxy.github.io/post-images/1617195153603.png" alt="" loading="lazy"><br>
<s>头上有绿</s>被涂上颜色的是一条重链，这个栗子里有五条重链，分别为：<br>
1---2---6---9<br>
5<br>
3<br>
4---7<br>
8</p>
<p>那么，我们需要维护什么？</p>
<blockquote>
<p>tree数组，表示整棵树上的信息<br>
tree[i].depth表示i的的深度<br>
tree[i].top表示i所在的重链顶端的结点<br>
tree[i].father表示i点的父亲<br>
tree[i].key表示i点的权值<br>
tree[i].To_tree表示节点i在线段树中的位置<br>
tree[i].size表示以i为根的子树大小<br>
tree[i].heavy_son表示i节点的重儿子<br>
To_num[i]表示线段树中的i号节点对应的是原树中的位置<br>
//鉴于我是个蒟蒻，这里之讲用数据结构线段树维护</p>
</blockquote>
<p><font color=green size=4><strong>CODE:</strong></font><br>
<img src="https://520cxy.github.io/post-images/1617195521550.png" alt="" loading="lazy"></p>
<p><font color=green size=4><strong>人工栈板CODE:</strong></font><br>
<img src="https://520cxy.github.io/post-images/1617195745240.png" alt="" loading="lazy"></p>
<p><font size=4 >其他运用啦</font><br>
<strong>LCA查询</strong><br>
比线段树牛bi多了，<s>代码也难的一批</s><br>
<strong>STEPS：</strong></p>
<blockquote>
<p>1.我们查看当前tree[x].top是否与tree[y].top相等<br>
2.如果不相等，那么就将深度较大的(假设为x)跳到当前重链顶端的父亲。<br>
3.一直这样迭代，直到它们top相等为止。<br>
4.如果它们的top相等，有两种情况：<br>
①x=y<br>
②y是x的祖先（或x是y的祖先）<br>
<font color=red>那么LCA就是深度较小的那一个！</font></p>
</blockquote>
<p><font color=green size=4><strong>CODE:</strong></font><br>
<img src="https://520cxy.github.io/post-images/1617196218239.png" alt="" loading="lazy"></p>
<p><strong>区间极值或和查询</strong><br>
在求LCA可以顺带操作一下，具体还是康代码吧::<br>
<font color=green size=4><strong>CODE:</strong></font><br>
<img src="https://520cxy.github.io/post-images/1617196594474.png" alt="" loading="lazy"></p>
<p><font size=4 ><strong>复杂度证明</strong></font><br>
<font color=red>------摘自OI Wiki, 因为我不会<font><br>
<img src="https://520cxy.github.io/post-images/1617196730978.png" alt="" loading="lazy"></p>
<p><font size=4 ><strong>该你大展身手了！！！</strong></font><br>
<a href="https://www.luogu.com.cn/problem/P3258">luogu P3258[JLOI2014]松鼠的新家</a><br>
<a href="https://www.luogu.com.cn/problem/P3178">luogu P3178[HAOI2015]树上操作</a><br>
<a href="https://www.luogu.com.cn/problem/P3384">luogu P3384【模板】树链剖分</a><br>
<a href="https://www.luogu.com.cn/problem/P2486">P2486 [SDOI2011]染色</a><br>
<a href="https://www.luogu.com.cn/problem/P3313">P3313 [SDOI2014]旅行</a></p>
]]></content>
    </entry>
</feed>