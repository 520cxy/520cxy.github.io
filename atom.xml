<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://520cxy.github.io</id>
    <title>LL.的小窝</title>
    <updated>2021-04-22T05:20:40.834Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://520cxy.github.io"/>
    <link rel="self" href="https://520cxy.github.io/atom.xml"/>
    <subtitle>共道人间惆怅事,不知今夕是何年 ——《周秦行纪》</subtitle>
    <logo>https://520cxy.github.io/images/avatar.png</logo>
    <icon>https://520cxy.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, LL.的小窝</rights>
    <entry>
        <title type="html"><![CDATA[DP分析]]></title>
        <id>https://520cxy.github.io/post/dp-fen-xi/</id>
        <link href="https://520cxy.github.io/post/dp-fen-xi/">
        </link>
        <updated>2021-04-19T05:43:59.000Z</updated>
        <content type="html"><![CDATA[<p><font size=6 color=red>1.为什么做dp要分析：</font><br>
比如，我们在计算123x456时，会使用竖式计算<s>你牛你口算</s>，<br>
<img src="https://520cxy.github.io/post-images/1618811515575.png" alt="" loading="lazy"><br>
但是要是我们口算234x567，对于我这种蒟蒻肯定是很困难的。<br>
那么做dp题目的时候也一样，很多时候我们做dp题目喜欢干瞪眼看， 确信。然后就空想，不动笔不动纸，那么这样情况下就白白给自己增加了很多难度。<font color=green>那么dp分析法，就是相当于乘法列竖式一样的一个使解决问题思路清晰的方式</font></p>
<p><font size=6 color=red>2.核心</font><br>
<font color=red>核心就是从集合的角度来分析dp问题</font><br>
回想我们之前做过的dp问题， 我们发现都是<font color=red>有限集内最优化、最值问题</font><br>
由于大多问题集内元素个数都为指数级，所以枚举运算起来的时间复杂度很高，因此我们要用dp优化</p>
<p><font color=red size=6>3.为什么dp可以优化这些问题</font><br>
<font color=green>dp过程中，要经历两个阶段</font><br>
<font color=blue size=5>阶段一：化零为整，即状态表示</font><br>
我们每次在处理问题时，不是一个方案一个方案，一个元素一个元素枚举，而是每次枚举一堆元素、枚举一个子集、枚举一类东西， 就是<font color=red>把一些有着相似性质的东西化为一个子集，用某个状态来表示， 就是化零为整的过程</font>。</p>
<p><font color=green>状态表示里我们一般要从两个角度分析</font>，，<br>
<font size=4 color=purple>第一个角度：</font><br>
我们的状态，比如f[i]，要考虑f[i]表示的是哪个集合，就是集合是什么。那么这个集合一般表述的方式就是：<font color=red>所有满足XXX条件的方案的集合。</font>正因为f[i]表示的是一类东西，所以枚举f[i]可以优化</p>
<p><font size=4 color=purple>第二个角度：</font><br>
第二个要考虑的就是f[i]虽然表示的是一个集合，但是存入数组的是一个数字或bool值。那么<font color=red>这个数和这个集合的关系，我们称为属性</font>，说白了就是我们这个集合存的是什么东西，<font color="#00dddd">属性一般有三种：maxn，minn，count</font></p>
<p><font color=blue size=5>阶段二：化整为零， 即状态计算</font><br>
与阶段一相反，这个等等举例。那么怎么去做？<font color=red>先看f[i]表示的所有状态是什么，然后把整个状态里看成一个集合，那么求f[i]就需要把整个集合划分为若干个子集。</font><br>
<img src="https://520cxy.github.io/post-images/1618814570057.png" alt="" loading="lazy"><br>
这些子集一般又符合两个原则；<br>
<font color=pink>原则一，不重复：</font>就是每个元素是单独属于其中一个子集；<br>
<font color=pink>原则二，不遗漏：</font>就是所有子集并集的元素一定把f[i]集合中所有元素都包含了。<br>
这时我们要求f[i]就是要求每个子集的值。<font color="#00dddd">比如我们现在f[i]的属性是最大值，那么整个集合最大值是什么，就是我们每个子集的最大值再取一个最大值；如果f[i]的属性是数量，那么整个集合的数量就是所有子集的数量之和。</font><br>
所以我们把<font color=red>整个集合的问题划分为若干个子集的小问题，我们去处理每个子集，再把每个子集计算后的结果整理得出f[i]的值，就是一个化整为零的过程</font>；<br>
有个要注意的地方，就是上面子集划分的两个原则，并不是一定所以情况下都要满足，首先不遗漏很清楚，要满足的，<font color=red>但是不重复需要注意：当我们求数量的时候，我们必须要满足不重复。但是当我们求最值的时候，其实可以重复，这点利用传递性很好理解，就是计算多了。</font></p>
<p>然后集合划分，我们一般也有个套路，我们一般是怎么去划分这个集合呢？<br>
<font color=red>划分依据：找最后一个不同点。</font></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原根代码及优化]]></title>
        <id>https://520cxy.github.io/post/yuan-gen-dai-ma-ji-you-hua/</id>
        <link href="https://520cxy.github.io/post/yuan-gen-dai-ma-ji-you-hua/">
        </link>
        <updated>2021-04-13T10:59:10.000Z</updated>
        <content type="html"><![CDATA[<p><font color=green size=5><strong>CODE</strong></font></p>
<pre><code class="language-c++">#include&lt;cstdio&gt;
#include&lt;cmath&gt;

typedef long long ll;
const int N = 2e5+1;

int q[N];
inline int phi(register int n){
    register int zc = n, all = sqrt(n);
    for(register int i = 2;i &lt;= all; ++i){
		if(n%i) continue;
    	zc = zc/i*(i-1);
    	while(n%i == 0) n /= i;
    }
    if(n &gt; 1) zc = zc/n*(n-1);
    return zc;
}

inline int pow(register int x,const int &amp;y,const int &amp;mod){
	register int res = 1;
	for(register int i = 1;i &lt;= y;i &lt;&lt;= 1, x = (ll)x*x%mod)
		if(i &amp; y) res = (ll)res*x%mod;
	return res;
}

inline int G(const int &amp;m){	
	const int PHI = phi(m);
	q[0] = 0;
	for(register int i = 2;i &lt; PHI; ++i)
		if(PHI%i == 0) q[++ q[0]] = i;
	for(register int g = 2;; ++g){
		bool fla = true;
		if(pow(g, PHI, m) != 1) continue;
		for(register int i = 1;i &lt;= q[0]; ++i)
			if(pow(g, q[i], m) == 1){
				fla = false;
				break;
			}
		if(fla) return g;
	}
}

int m;
signed main(int argc, char const* argv[]){
	scanf(&quot;%d&quot;, &amp;m);
    printf(&quot;%d&quot;, G(m));
    return 0;
}
</code></pre>
<p>这是最常用的方法<br>
如果你还想要更优的复杂度：<br>
删去</p>
<pre><code class="language-c++">q[0] = 0;
	for(register int i = 2;i &lt; PHI; ++i)
		if(PHI%i == 0) q[++ q[0]] = i;
</code></pre>
<p>加上</p>
<pre><code class="language-c++">q[0] = 0;
const int limit = sqrt(PHI);
for(register int i = 2;i &lt;= limit; ++i)
    if(PHI % i == 0){
        q[++ q[0]] = i;
        if(i*i != PHI) q[++ q[0]] = PHI/i;
    }
</code></pre>
<p>枚举时间就为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>m</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">m</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>) + O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>m</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">m</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>)*O(logm)*O(g)</p>
<p>还有更快的！！！<br>
现在发现瓶颈在枚举的数量上，其实还可以优化<br>
有一个结论：设φ ( m ) = p<sub>1</sub><sup>a<sub>1</sub></sup> * p<sub>2</sub><sup>a<sub>2</sub></sup> * ... * p<sub>n</sub><sup>a<sub>n</sub></sup><br>
那么只需要判断：<img src="https://520cxy.github.io/post-images/1618471759699.png" alt="" loading="lazy"><br>
如果有一个条件满足，那么当前的g一定不是原根如果对于一个φ(m)的因数b满足了条件，那么在这些数当中一定至少有一个也满足这个条件，然后就好啦<br>
代码依然用替换来给出，替换上文提到的地方</p>
<pre><code class="language-c++">q[0]=0;
const int limit=sqrt(PHI);
int zc=PHI;
for(register int i=2;i&lt;=limit;i++)
	if(zc%i==0){
		q[++q[0]]=PHI/i;
		while(zc%i==0)zc/=i;
	}
if(zc&gt;1)zc=q[++q[0]]=PHI/zc;
</code></pre>
<p>时间就成O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>m</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">m</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>)+O(log<sup>2</sup>m)*O(g)<br>
完结撒花</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4.5 Solution]]></title>
        <id>https://520cxy.github.io/post/45-solution/</id>
        <link href="https://520cxy.github.io/post/45-solution/">
        </link>
        <updated>2021-04-05T06:46:08.000Z</updated>
        <content type="html"><![CDATA[<p><font size=6>T1:纯粹理性批判</font><br>
<font size=4>题目描述：</font><br>
<img src="https://520cxy.github.io/post-images/1617605412575.png" alt="" loading="lazy"><br>
样例输入：10<br>
样例输出：21<br>
<font size=4>方法：</font><br>
我们将所有a, b的情况分为三类 ：<br>
<font color=green>1. a = b 时</font>， 显然不可能(自己举栗子)<br>
<font color=green>2. a &gt; b 时</font>， 此时<font color=blue>b/a = 0</font> 要满足a%b = 0， 则<font color=red>所求二元组为b是a的因子</font><br>
<font color=green>3. a &lt; b 时</font>，此时<font color=blue>a%b = a</font> 要满足b/a=a， 则<font color=red>所求二元组数为区间数量a<sup>2</sup> &lt; b &lt; a<sup>2</sup>+a</font><br>
然后统计答案</p>
<p><font size=6>T2:自我救赎</font><br>
<font size=4>题目描述：</font><br>
<img src="https://520cxy.github.io/post-images/1617607036161.png" alt="" loading="lazy"><br>
样例输入:<br>
5<br>
5 4 3 2 1<br>
样例输出:<br>
4<br>
<font size=4>方法：</font></p>
<blockquote>
<p>数据太水O(n<sup>2</sup>)暴力枚举，只要往后扫，一碰到比它大的就++，break，直接过</p>
</blockquote>
<p><font size=6>T4:失乐园</font><br>
<font size=4>题目描述：</font><br>
<img src="https://520cxy.github.io/post-images/1617607354812.png" alt="" loading="lazy"><br>
样例输入：<br>
8<br>
20152016<br>
样例输出：<br>
4<br>
样例解释：<br>
”20152016” = ”20152016”<br>
”20152016” = ”20” + ”152016”<br>
”20152016” = ”201” + ”52016”<br>
”20152016” = ”2015” + ”2016”</p>
<p><font size=4>方法：</font><br>
<font color=red>区间DP</font>，<br>
但是要先做一个LCP（最长公共前缀）优化<s>我不会</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4.2 Solution]]></title>
        <id>https://520cxy.github.io/post/42-solution/</id>
        <link href="https://520cxy.github.io/post/42-solution/">
        </link>
        <updated>2021-04-02T02:04:33.000Z</updated>
        <content type="html"><![CDATA[<p><font size=5>T1 生成字符串</font><br>
在模拟的时候发现，如果他给出了<font color=red>连续的n个T<sub>1</sub>操作，就是翻转n%2次</font>，而串首串尾加字符，如果加了以后翻转，就等价于反着加，我们只需要记下每次操作填补的位置最后进行操作就行；</p>
<p><font size=5>T2 字符串查询</font><br>
据dalao们说是线段树和树状数组的维护，<s>我也看出来了</s>，但是我没<s>马</s>码；</p>
<p><font size=5>T3 下取整</font><br>
只要按照题目描述的进行操作之后，存下来的数和原数比较，反正我是做了一遍<font color=red>数学的逆运算</font>就切了唔</p>
<p><font size=5>T4 整除</font><br>
原题：<a href="https://atcoder.jp/contests/abc158/tasks/abc158_e">ABC158 E - Divisible Substring</a><br>
思维题，有一个很特别的性质吧，我也不知道叫什么，<font color=red>比如你的s[i]%p=k, s[j]%p=k,那么，<img src="https://520cxy.github.io/post-images/1617330955337.png" alt="" loading="lazy"></font><br>
<font color=green>所以在区间[i, j]中的数都能取，之后统计i~j中所有区间长度的区间个数累计加起来</font><br>
还有就是要注意p=2, 5的情况需要特判，由于这俩很好判断，<font color=red>只要末尾上的数可以整除那么前面一系列数都能取</font></p>
<p><font size=5>T5 机器人</font><br>
原题：<a href="https://atcoder.jp/contests/abc158/tasks/abc158_f">ABC158 F - Removing Robots</a><br>
首先这是一个DAG模型，一个机器的激活可以引起另一个的激活，这样我们根据某一机器人向能够引起爆炸的另外一个机器人连边便可以得到一张<font color=red>有向无环图</font><br>
事实上，有向无环图我们很难建立而且很难在上面完成答案的计算；<br>
因此题解中有一个很妙的思路：</p>
<blockquote>
<p>将DAG中多余的边去掉，使其变成一个树结构<br>
我们将<strong>多于的边去掉首先需要保证的是不会影响答案的计算</strong></p>
</blockquote>
<p>例如(A,B),(B,C),(A,C)这三条边中我们完全可以将(A,C)去掉，因为这两条路径是等价的。<br>
因此我们对于每一节点，只需要<font color=red>向离节点最左边位置的节点连边</font>即可。<br>
在程序实现上，我们可以使用优先队列/栈来维护：<br>
我们反向考虑，对于没有受到连边的节点放到一个容器使得容器的顶部位置最小。<br>
（为了能更容易的得到连边）<br>
若当前可以向容器的顶部连边，则连边并弹出顶部，直到不能连边为止。<br>
<font color=green>最优我们得到了一个森林结构，我们以每一个根为起点做树形DP。<br>
DP很很好写——xhf dalao</font><br>
我们设f[i]表示以i为根子树的选择方案。<br>
当i启动时，子树都需要启动，方案为1。<br>
当i不启动时，方案为子树的f值得积<br>
最后的答案是森林中每一个根的f值之积。<br>
<img src="https://520cxy.github.io/post-images/1617330304397.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一些数学芝士]]></title>
        <id>https://520cxy.github.io/post/yi-xie-shu-xue-zhi-shi/</id>
        <link href="https://520cxy.github.io/post/yi-xie-shu-xue-zhi-shi/">
        </link>
        <updated>2021-04-01T06:34:13.000Z</updated>
        <content type="html"><![CDATA[<p><font size=6 color=red></font><br>
<font size=6 color=purple>前置芝士</font></p>
<blockquote>
<p>1.阶：若a, p互质, 使a<sup>l</sup> % p==1,的最小正整数l定义为a模p意义下的阶, 记作ord<sub>p</sub> a；<br>
2.欧拉函数：给出一个正整数x，函数值np定义为0~x内与x互质的数的个数，记作φ(x)=n<br>
3.欧拉定理：a<sup>φ(p)</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≡</span></span></span></span> 1(mod p)</p>
</blockquote>
<p><font size=6 color=red >原根：</font><br>
<font size=4 color=blue>定义：</font></p>
<blockquote>
<p>那么<font color=red>若ord<sub>p</sub>a=φ(p), 则称a是模p意义下的原根，归根到底就是g<sup>(P-1)</sup> = 1 (mod P)当且仅当指数为P-1的时候成立。(这里P是素数)。</font></p>
</blockquote>
<p><font size=4 color=blue>求法:</font><br>
1.<strong>暴力求解</strong>：<br>
求n的原根时，由于原根都比较小，所以我们可以将原根g从2开始枚举，判断ord<sub>n</sub> g == φ(n)?代码就不放了<br>
2.<strong>稍快的方法</strong>：<br>
上一个暴力的复杂度就是φ(m)*log(m)*O(g)，笑死了，在大质数的时候完全跑不动，这是oiers所不能接受的<s>要快！</s>。<br>
容易发现：我们在枚举g的时候只要枚举与m互质的数，若不互质，那么一定不满足一一对应的条件<br>
不过很多情况下我们要求的都是一个质数的原根，所以这个优化不常用（噗呲<br>
3.<strong>更快的方法！</strong><br>
在上面的代码中枚举i时发现：i不是每个都有用的。给出一个<s>玄学的</s>结论：<font color=red>枚举i只需要枚举φ(m)的因数就好了</font>证明：不会，自己问度娘。<br>
代码：在专篇里<br>
一般这个方法就够了复杂度就O(m)+O( m)∗O(logm)∗O(g)<br>
还有更优化方法，也在专篇里，这里就不放了，内容有点小多TwT</p>
<p><font size=6 color=red>扩展欧拉定理：</font><br>
<font color=green><s>oiers</s>我从来都只记结论，不会证明。确信</font><br>
<a href="https://www.luogu.com.cn/problem/P5091">例题</a><br>
求a<sup>c</sup> mod m<br>
显然，由于m和c会非常大，一般方法肯定不行<br>
于是，扩展欧拉定理诞生了！！！<br>
<font color=red>若gcd(a, m) == 1</font> ，即底数与模数互质时，根据欧拉定理<br>
<img src="https://520cxy.github.io/post-images/1618299104331.png" alt="" loading="lazy"><br>
<font color=red>若gcd(a, m) != 1 &amp;&amp; c&lt;φ(m)</font>，<s>根据扩展欧拉定理</s><br>
<img src="https://520cxy.github.io/post-images/1618299216215.png" alt="" loading="lazy"><br>
<font color=red>若gcd(a, m) != 1 &amp;&amp; c≥φ(m)时</font> 根据扩展欧拉定理：<br>
<img src="https://520cxy.github.io/post-images/1618299283790.png" alt="" loading="lazy"><br>
那么：<font size=4 color=green>馬媽再也不用担心指数爆炸啦，因为指数也能取模啦！！！</font></p>
<p><font size=6 color=red>二次剩余和N次剩余</font><br>
<font size=5 color=blue>二次剩余</font><br>
<a href="https://www.luogu.com.cn/problem/P5491">例题</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Re:树链剖分的起源之战]]></title>
        <id>https://520cxy.github.io/post/reshu-lian-pou-fen-de-qi-yuan-zhi-zhan/</id>
        <link href="https://520cxy.github.io/post/reshu-lian-pou-fen-de-qi-yuan-zhi-zhan/">
        </link>
        <updated>2021-03-31T12:26:49.000Z</updated>
        <content type="html"><![CDATA[<p><font size=6><strong>哲学</strong>三问</font><br>
<font size=4 >一.树链剖分是啥？</font><br>
<font color=red>树链，就是树上的路径。剖分，就是把路径分类为重链和轻链。</font><br>
<font size=4 >二.树链剖分用来干啥？</font></p>
<blockquote>
<p>有的人说：“我会树上倍增，我怕谁？”，没错，你怕的就是树链剖分。<br>
意思是：树上倍增能做的，树链剖分都能做；树链剖分能做的，树上倍增不一定能做<s>就像那啥，树状数组能做的线段树一定能做，线段树能做的，树状数组不一定能做</s>。树上倍增虽然能求树上区间极值或和，但一旦有树上边或点权值修改的操作，您就爆dan了这时我们需要一个新的算法来补上我们的树上倍增操作的漏洞，没错，就是<strong>树链剖分</strong>！没错！你学了它<s>一定</s>不会后悔！!</p>
</blockquote>
<p><a href="https://edge-bird.github.io/2021/01/30/Binary%20Index%20Tree/">树状数组</a> &lt;--- 不会点这里，<s>营销大鸟</s>的blog<br>
<font color=red>在一棵树上进行路径的修改、求极值、求和”</font>乍一看只要线段树就能轻松解决，实际上，仅凭线段树是不能搞定它的。我们需要用到一种<s>貌似</s>高级的复杂算法—<strong>树链剖分</strong></p>
<p><font size=4 >三.树链剖分咋用？</font><br>
如果要使用树链剖分，概念滴你们滴需要懂滴</p>
<blockquote>
<p>对于一个节点，在它的所有儿子中，size（子树大小）最大的一个就是<strong>重儿子</strong>，其余的都是<strong>轻儿子</strong>。重儿子所在的树链叫做<strong>重链</strong>，其余叫做<strong>轻链</strong>。</p>
</blockquote>
<p><font color=blue>e.g:</font><img src="https://520cxy.github.io/post-images/1617195153603.png" alt="" loading="lazy"><br>
<s>头上有绿</s>被涂上颜色的是一条重链，这个栗子里有五条重链，分别为：<br>
1---2---6---9<br>
5<br>
3<br>
4---7<br>
8</p>
<p>那么，我们需要维护什么？</p>
<blockquote>
<p>tree数组，表示整棵树上的信息<br>
tree[i].depth表示i的的深度<br>
tree[i].top表示i所在的重链顶端的结点<br>
tree[i].father表示i点的父亲<br>
tree[i].key表示i点的权值<br>
tree[i].To_tree表示节点i在线段树中的位置<br>
tree[i].size表示以i为根的子树大小<br>
tree[i].heavy_son表示i节点的重儿子<br>
To_num[i]表示线段树中的i号节点对应的是原树中的位置<br>
//鉴于我是个蒟蒻，这里之讲用数据结构线段树维护</p>
</blockquote>
<p><font color=green size=4><strong>CODE:</strong></font><br>
<img src="https://520cxy.github.io/post-images/1617195521550.png" alt="" loading="lazy"></p>
<p><font color=green size=4><strong>人工栈板CODE:</strong></font><br>
<img src="https://520cxy.github.io/post-images/1617195745240.png" alt="" loading="lazy"></p>
<p><font size=4 >其他运用啦</font><br>
<strong>LCA查询</strong><br>
比线段树牛bi多了，<s>代码也难的一批</s><br>
<strong>STEPS：</strong></p>
<blockquote>
<p>1.我们查看当前tree[x].top是否与tree[y].top相等<br>
2.如果不相等，那么就将深度较大的(假设为x)跳到当前重链顶端的父亲。<br>
3.一直这样迭代，直到它们top相等为止。<br>
4.如果它们的top相等，有两种情况：<br>
①x=y<br>
②y是x的祖先（或x是y的祖先）<br>
<font color=red>那么LCA就是深度较小的那一个！</font></p>
</blockquote>
<p><font color=green size=4><strong>CODE:</strong></font><br>
<img src="https://520cxy.github.io/post-images/1617196218239.png" alt="" loading="lazy"></p>
<p><strong>区间极值或和查询</strong><br>
在求LCA可以顺带操作一下，具体还是康代码吧::<br>
<font color=green size=4><strong>CODE:</strong></font><br>
<img src="https://520cxy.github.io/post-images/1617196594474.png" alt="" loading="lazy"></p>
<p><font size=4 ><strong>复杂度证明</strong></font><br>
<font color=red>------摘自OI Wiki, 因为我不会<font><br>
<img src="https://520cxy.github.io/post-images/1617196730978.png" alt="" loading="lazy"></p>
<p><font size=4 ><strong>该你大展身手了！！！</strong></font><br>
<a href="https://www.luogu.com.cn/problem/P3258">luogu P3258[JLOI2014]松鼠的新家</a><br>
<a href="https://www.luogu.com.cn/problem/P3178">luogu P3178[HAOI2015]树上操作</a><br>
<a href="https://www.luogu.com.cn/problem/P3384">luogu P3384【模板】树链剖分</a><br>
<a href="https://www.luogu.com.cn/problem/P2486">P2486 [SDOI2011]染色</a><br>
<a href="https://www.luogu.com.cn/problem/P3313">P3313 [SDOI2014]旅行</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Me]]></title>
        <id>https://520cxy.github.io/post/about/</id>
        <link href="https://520cxy.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！</p>
</blockquote>
<h2 id="欢迎和我交朋友">欢迎和我交朋友！</h2>
<h2 id="博猪是zj的一枚蒟蒻~~">👨‍💻 博猪是ZJ的一枚蒟蒻~~</h2>
<h2 id="喜欢篮球篮球plmm">喜欢篮球，篮球，<s>plmm</s></h2>
<h2 id="你谷"><a href="https://www.luogu.com.cn/user/228866">你谷</a> qq 号：2949287507</h2>
]]></content>
    </entry>
</feed>